import time
import torch
import random
import os
import sys
import copy
import pickle
import numpy as np
import os.path as osp
from utils import draw_sub_type_map
from trainer import train_model
from data_handler import generate_data


class Args:
    def __init__(self, seed=42, data_name='T50_PE', time_stamp='1111_1111',
                 data_path='generated/', model_path='model/', embedding_data_path='embeddings/',
                 result_path='results/', num_epoch=200, hidden=256, n_clusters=2, gpu=0, n_input=2048):
        self.seed = seed
        self.data_name = data_name
        self.time_stamp = time_stamp
        self.raw_path = 'datasets/'
        self.data_path = data_path
        self.model_path = model_path
        self.embedding_data_path = embedding_data_path
        self.result_path = result_path
        self.num_epoch = num_epoch
        self.hidden = hidden
        self.n_clusters = n_clusters

        self.pre_train_epoch = 30
        self.n_input = n_input
        self.n_z = self.n_input // 10
        self.lr = 1e-3
        self.pretrain_path = 'ae.pkl'
        self.gpu = gpu
        self.bsz = 1
        self.use_whole_gene = False

def prepare(seed=42, dataset='T25_F1', num_epoch=1000, n_input=3000):
    time_stamp = time.strftime("%m%d_%H%M")
    torch.manual_seed(seed)
    random.seed(seed)
    np.random.seed(seed)
    rootPath = os.path.dirname(sys.path[0])
    os.chdir(rootPath)
    # os.chdir('../..')
    dstc_args = Args(data_name=dataset, time_stamp=time_stamp, num_epoch=num_epoch, n_input=n_input, seed=seed)
    generate_data(dstc_args)
    return dstc_args

def train(dstc_args, n_nei=6, spatial_regularization_strength=3,
          target_types = ['OLG', 'ASC'],
          bad_types = ['EC']):
    meta_folder = osp.join(dstc_args.data_path, dstc_args.data_name)
    types_dic = np.loadtxt(meta_folder + '/types_dic.txt', delimiter='\t', dtype=str)
    for bi_type in types_dic:
        if bi_type not in bad_types and bi_type in target_types:
            args = copy.deepcopy(dstc_args)
            device = torch.device(args.gpu if torch.cuda.is_available() else 'cpu')
            # cell_type_indeces = np.load(meta_folder + f"/cell_type_indeces_{bi_type.replace('/', 'or')}.npy")
            method = f"{bi_type.replace('/', 'or')}_lambda_sp_re={spatial_regularization_strength}_n_epoch={args.num_epoch}_weight_DSTC_{args.n_input}_with_CCST_adj_{n_nei}_i"
            # method = f"{bi_type.replace('/', 'or')}_lambda_g={graph_regularization_strength}_weight_DSTC_{args.n_input}_with_CCST_adj_i"
            args.embedding_data_path = osp.join(args.embedding_data_path, args.data_name, method, args.time_stamp)  # Tid: out
            args.model_path = osp.join(args.model_path, args.data_name, method)
            args.result_path = osp.join(args.result_path, args.data_name, args.time_stamp, method)
            if not os.path.exists(args.embedding_data_path): # Embedding dir.
                os.makedirs(args.embedding_data_path) 
            if not os.path.exists(args.model_path): # Model dir.
                os.makedirs(args.model_path) 
            if not os.path.exists(args.result_path): # Results dir.
                os.makedirs(args.result_path) 

            print ('------------------------Model and Training Details--------------------------')
            print({**vars(args)})

            # Get data
            coords = np.load(osp.join(args.data_path, args.data_name) + '/coordinates.npy')
            X_data = np.load(osp.join(args.data_path, args.data_name) + '/features.npy')
            # data_folder = osp.join(args.data_path, args.data_name, 'SPACE') # Adj is generated by SPACE
            data_folder = osp.join(args.data_path, args.data_name) # Adj is generated by CCST
            with open(data_folder + f'/adj_{n_nei}_i', 'rb') as fp:
                adj_0 = pickle.load(fp)
            with open(data_folder + f'/lr_cell_weight', 'rb') as fp:
                attn_LRs = pickle.load(fp)

            adj = adj_0

            num_cell = X_data.shape[0]
            num_feature = X_data.shape[1]
            print('Adj:', adj.shape, 'Edges:', len(adj.data))
            print('X:', X_data.shape)

            # n_clusters = max(cell_type_indeces) + 1 #num_cell_types, start from 0

            # print('n clusters:', n_clusters)

            print("-----------DSTC-------------")
            if 'SPACE' in data_folder:
                adj = torch.Tensor(adj).to(device)
            else:
                adj = torch.Tensor(adj.toarray()).to(device)
            data = torch.Tensor(X_data).to(device)
            attn_LRs = {k: torch.Tensor(v.toarray()).to(device) for k, v in attn_LRs.items()}

            train_model(args, data, adj, coords, attn_LRs, spatial_regularization_strength, device)

            print("-----------Drawing map-------------")

            node_embed = np.load(args.embedding_data_path + '/spot_embed.npy') 
            draw_sub_type_map(bi_type, args.data_name, types_dic, node_embed, method, args.time_stamp, args.seed) # Debug


# Test
args = prepare()
train(args)