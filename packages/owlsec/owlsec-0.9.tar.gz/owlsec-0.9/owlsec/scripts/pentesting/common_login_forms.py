import requests
import urllib
import urllib3
from bs4 import BeautifulSoup

# Suppress only the single specific warning from urllib3
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

login_details = {"username": "test@test.com", "password": "testpassword"}
usernames_set = {"username", "user", "email", "login", "log", "userid", "user_id", "loginid", "login_id", "emailid", "email_id", "name", "user_name", "emailaddress", "loginname", "uname", "admin_email", "login_username"}
passwords_set = {"pass", "password", "pwd", "passwd", "passcode", "pass_id", "password_id", "pass", "pass_word", "loginpass", "userpass", "userpwd", "admin_password", "login_passwd"}
directories = ["/", "/admin/sign_in", "/admin", "/login", "/dashboard", "/signin", "/wp-admin", "/administrator", "/backend", "/mail", "/webmail", "/Main_Login.asp"]

def process_subdomain(subdomain):
    results = []

    base_url = subdomain.strip()

    # Ensure that the base_url always has a protocol (http/https)
    if not base_url.startswith(('http://', 'https://')):
        base_url = 'http://' + base_url  # Defaulting to http if no protocol specified

    for directory in directories:
        url = urllib.parse.urljoin(base_url, directory)
        response = None  
        #print(f"[DEBUG] Searching {url} for login forms")
        try:
            headers = {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.85 Safari/537.3'}
            response = requests.get(f"{url}", headers=headers, verify=False, timeout=10)
        except requests.exceptions.RequestException as e:
            continue

        if response:
            soup = BeautifulSoup(response.text, 'html.parser')
            forms = soup.find_all('form')

            for form in forms:  
                result = process_form(form, url)
                results.append(result)
    return results

def process_form(form, url):
    result = {'url': url, 'form': {}, 'post': None}
    params = {}
    user_field_found = False
    pass_field_found = False
    for input in form.find_all('input'):
        if input.get("name"):
            default_value = input.get('value', '')
            if (input.get("name") and input.get("name").lower() in usernames_set) or \
                    (input.get("id") and input.get("id").lower() in usernames_set) or \
                    (input.get("placeholder") and input.get("placeholder").lower() in usernames_set):
                params[input.get("name")] = login_details["username"]
                user_field_found = True
            elif (input.get("type") == "password") or (input.get("name") and input.get("name").lower() in passwords_set) or \
                    (input.get("id") and input.get("id").lower() in passwords_set) or \
                    (input.get("placeholder") and input.get("placeholder").lower() in passwords_set):
                params[input.get("name")] = login_details["password"]
                pass_field_found = True
            else:
                params[input.get("name")] = default_value

    action = form.get('action')
    if not urllib.parse.urlparse(action).netloc:
        action = urllib.parse.urljoin(url, action)
    elif action.startswith('//'):
        action = 'https:' + action

    result['form'] = {'action': action, 'params': params}

    if user_field_found and pass_field_found:
        try:
            post_response = requests.post(action, data=params, verify=False, timeout=10)
            parsed_url = urllib.parse.urlparse(post_response.url)
            post = {'method': 'POST', 'path': parsed_url.path, 'host': parsed_url.netloc, 'headers': {}, 'params': params}
            for key, value in post_response.request.headers.items():
                if key.lower() != 'host':
                    post['headers'][key] = value
            result['post'] = post
        except requests.exceptions.RequestException as e:
            pass

    return result

def print_results(results):
    output = {}
    for result in results:
        action_key = result["form"]["action"]
        output[action_key] = {
            'form_parameters': f'{action_key}?{urllib.parse.urlencode(result["form"]["params"])}',
            'possible_login_form': 'Possible login form found. POST request sent.' if result['post'] else None,
            'request': format_request(result) if result['post'] else None
        }
    return output

def format_request(result):
    request_output = []
    request_output.append(f'{result["post"]["method"]} {result["post"]["path"]} HTTP/1.1')
    request_output.append(f'Host: {result["post"]["host"]}')
    for key, value in result["post"]["headers"].items():
        request_output.append(f'{key}: {value}')
    request_output.append('')
    request_output.append(urllib.parse.urlencode(result["post"]["params"]))
    return "\n".join(request_output)

def get_burp_responses(subdomain):
    processed_results = process_subdomain(subdomain)
    return print_results(processed_results)

if __name__ == "__main__":
    subdomain_to_check = "google.com"
    responses = get_burp_responses(subdomain_to_check)
    
    # Example usage
    for action_key, details in responses.items():
        print(f"Action URL: {action_key}")
        print(f"Form Parameters: {details['form_parameters']}")
        print(f"Status: {details['possible_login_form']}")
        if details['request']:
            print("Request:")
            print(details['request'])
        print("-" * 40)
