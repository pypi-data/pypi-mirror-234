import socket
import concurrent.futures

# List of the top 100 commonly used ports for both TCP and UDP
top_ports = [
    21, 22, 23, 25, 53, 80, 110, 139, 143, 443, 445, 587, 993, 995,
    1433, 1521, 3306, 3389, 5000, 5432, 5900, 8080, 8443, 9090, 9999,
    27017, 28017, 50000, 50070, 11211, 27015, 28015, 6881, 6969,
    8000, 8008, 8444, 8888, 9000, 9100, 9200, 9418, 27018, 27019,
    27020, 27021, 27022, 27023, 27024, 27025, 27026, 27027, 27028,
    27029, 27030, 27031, 27032, 27033, 27034, 27035, 27036, 27037,
    27038, 27039, 27040, 27041, 27042, 27043, 27044, 27045, 27046,
    27047, 27048, 27049, 27050, 27051, 27052, 27053, 27054, 27055,
    27056, 27057, 27058, 27059, 27060, 27061, 27062, 27063, 27064,
    27065, 27066, 27067, 27068, 27069, 27070, 27071, 27072, 27073,
    27074, 27075, 27076, 27077, 27078, 27079, 27080, 27081, 27082,
    27083, 27084, 27085, 27086, 27087, 27088, 27089, 27090, 27091,
    27092, 27093, 27094, 27095, 27096, 27097, 27098, 27099, 27100
]

def scan_tcp_port(ip, port):
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            s.settimeout(1)
            result = s.connect_ex((ip, port))
            if result == 0:
                return port, "Open"
            else:
                return port, "Closed"
    except Exception as e:
        #print(f"[ERROR] {port}/TCP: {e}")
        return port, "Closed"

def scan_udp_port(ip, port):
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as s:
            s.settimeout(1)
            s.sendto(b'', (ip, port))
            data, _ = s.recvfrom(1024)
            if data:
                return port, "Open"
            else:
                return port, "Open/Filtered"
    except socket.timeout:
        return port, "Open/Filtered"
    except Exception as e:
        #print(f"[ERROR] {port}/UDP: {e}")
        return port, "Closed"

def port_scan(target, max_threads=50):
    open_tcp_ports = []
    open_udp_ports = []
    
    with concurrent.futures.ThreadPoolExecutor(max_workers=max_threads) as executor:
        tcp_futures = [executor.submit(scan_tcp_port, target, port) for port in top_ports]
        udp_futures = [executor.submit(scan_udp_port, target, port) for port in top_ports]
        
        for future in concurrent.futures.as_completed(tcp_futures):
            port, status = future.result()
            if status == "Open":
                open_tcp_ports.append(port)

        for future in concurrent.futures.as_completed(udp_futures):
            port, status = future.result()
            if status == "Open":
                open_udp_ports.append(port)
    
    return open_tcp_ports, open_udp_ports  # Add this line

if __name__ == "__main__":
    target_ip = "192.168.1.1"  # Replace with the IP you want to scan
    
    tcp_ports, udp_ports = port_scan(target_ip)

    # Example usage
    print(f"Open TCP ports: {', '.join(map(str, tcp_ports))}")
    print(f"Open UDP ports: {', '.join(map(str, udp_ports))}")
