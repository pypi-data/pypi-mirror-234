import os
import subprocess
import platform
import logging
import requests
import zipfile
import shutil

def download_and_extract_file(download_url):
    # Get the current directory where the script is located
    script_directory = os.path.dirname(os.path.abspath(__file__))

    # Define the directory where you want to save the downloaded and extracted file
    download_directory = os.path.join(script_directory, "downloaded_files")

    # Create the download directory if it doesn't exist
    os.makedirs(download_directory, exist_ok=True)

    # Extract the file name from the URL
    file_name = download_url.split("/")[-1]

    # Define the path for the downloaded zip file
    zip_file_path = os.path.join(download_directory, file_name)

    # Send an HTTP GET request to the URL and download the file
    response = requests.get(download_url)

    if response.status_code == 200:
        with open(zip_file_path, "wb") as file:
            file.write(response.content)
        #print(f"Downloaded {file_name} successfully!")

        # Extract the downloaded zip file
        with zipfile.ZipFile(zip_file_path, "r") as zip_ref:
            zip_ref.extractall(download_directory)
        #print(f"Extracted {file_name} successfully!")

        # Clean up: Remove the downloaded zip file
        os.remove(zip_file_path)
        #print(f"Removed {file_name}")

        # Move the extracted files to the script directory
        executable_file_name = "httpx.exe" if platform.system() == "Windows" else "httpx"
        extracted_files = [executable_file_name, "LICENSE.md", "README.md"]

        for file in extracted_files:
            source_path = os.path.join(download_directory, file)
            target_path = os.path.join(script_directory, file)
            shutil.move(source_path, target_path)
            #print(f"Moved {file} to {script_directory}")

        # Clean up: Remove the empty download directory
        shutil.rmtree(download_directory)

        # Clean up: Remove LICENSE.md and README.md in the script directory
        for file in ["LICENSE.md", "README.md"]:
            file_path = os.path.join(script_directory, file)
            if os.path.exists(file_path):
                os.remove(file_path)
                #print(f"Removed {file} in {script_directory}")
    else:
        print(f"Failed to download {file_name}. Status code: {response.status_code}")


def ensure_httpx_installed():
    script_dir = os.path.dirname(os.path.realpath(__file__))
    httpx_exe = 'httpx.exe' if platform.system() == 'Windows' else 'httpx'
    httpx_path = os.path.join(script_dir, httpx_exe)

    # Check if the file doesnâ€™t exist
    if not os.path.exists(httpx_path):
        print(f"{httpx_exe} not found, downloading...")
        
        # Determine the URL based on OS
        base_url = "https://github.com/projectdiscovery/httpx/releases/download/v1.3.5/httpx_1.3.5_"
        download_url = f"{base_url}windows_386.zip" if platform.system() == 'Windows' else f"{base_url}linux_386.zip"
        
        download_and_extract_file(download_url)
    return True


KEYWORDS = ["cloudflare", "wordpress", "joomla", "apache", "shopify", 
            "wix", "cloudfront", "amazon", "digitalocean", "react", "nginx", 
            "fastly", "akamai", "hsts", "varnish", "bootstrap", "vue.js"]

def run_httpx_for_domain(domain, port=None):
    ensure_httpx_installed()
    target = domain if port is None else f"{domain}:{port}"
    
    if not domain:
        return {'status': 'dead', 'httpx_output': 'Domain is missing.', 'detected_keywords': []}

    script_dir = os.path.dirname(os.path.realpath(__file__))
    httpx_exe = 'httpx.exe' if platform.system() == 'Windows' else 'httpx'
    httpx_path = os.path.join(script_dir, httpx_exe)

    # Check if it is Linux and file is not executable
    if platform.system() == 'Linux' and not os.access(httpx_path, os.X_OK):
        try:
            # Make it executable
            os.chmod(httpx_path, os.stat(httpx_path).st_mode | 0o111)  # 0o111 is octal for executable permission
        except Exception as e:
            # Print error message and return
            print(f"Failed to make {httpx_path} executable: {str(e)}")

            print("\n[ERROR] Failed to make httpx executable!")
            print("Please manually download the 'httpx' package from the HTTPx github,")
            print("https://github.com/projectdiscovery/httpx/releases/download/v1.3.5/httpx_1.3.5_linux_386.zip")
            print("unzip it and move the httpx file to this folder: {}".format(script_dir))
            print("and run 'chmod +x httpx' for it to work.\n")
            print('Do one line at a time if you are lazy (change username ):')
            print("wget https://github.com/projectdiscovery/httpx/releases/download/v1.3.5/httpx_1.3.5_linux_386.zip")
            print("unzip httpx_1.3.5_linux_386.zip")
            print("chmod +x httpx")
            print("mv httpx {}".format(script_dir))
            return {'status': 'dead', 'httpx_output': f'Error: {str(e)}', 'detected_keywords': []}

    cmd = [
        httpx_path, "-u", target, "-title", "-tech-detect", "-status-code", 
        "-asn", "-cl", "-ct", "-location", "-rt", "-lc", "-wc", "-server", 
        "-method", "-ip", "-cname", "-cdn", "-probe", "-nc", "-silent"
    ]
    
    try:
        command_to_run = ' '.join(cmd)
        result = subprocess.check_output(command_to_run, stderr=subprocess.STDOUT, shell=True).decode('utf-8')

        # Log the result to debug
        logging.debug(f"HTTPX Result for {target}: {result}")

        # Extract relevant info without parsing the full httpx output
        is_alive = "[FAILED]" not in result
        status = "alive" if is_alive else "dead"
        detected_keywords = keywords_in_httpx_result(result)

        # Removing the domain layer in the returned dictionary
        return {
            "raw_output": result.strip(),
            "status": status,
            "detected_keywords": detected_keywords
        }

    except subprocess.CalledProcessError as e:
        result = e.output.decode('utf-8', errors='replace')
        # Removing the domain layer in the returned dictionary
        print(result)
        return {
            "raw_output": result.strip(),
            "status": "dead",
            "detected_keywords": []
        }
        
def keywords_in_httpx_result(httpx_result):
    found_keywords = [keyword for keyword in KEYWORDS if keyword.lower() in httpx_result.lower()]
    return found_keywords

if __name__ == "__main__":
    domain = "google.com"
    result = run_httpx_for_domain(domain)
    
    print("HTTPX Result:")
    print("=============")
    print(result['raw_output'])
    print("\nDetected Keywords:")
    print("==================")
    print(", ".join(result['detected_keywords']))
