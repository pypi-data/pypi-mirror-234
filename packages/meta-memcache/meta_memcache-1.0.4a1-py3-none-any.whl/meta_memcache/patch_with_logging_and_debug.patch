diff --git a/src/meta_memcache/base/base_cache_pool.py b/src/meta_memcache/base/base_cache_pool.py
index 85b2e21..b07a68f 100644
--- a/src/meta_memcache/base/base_cache_pool.py
+++ b/src/meta_memcache/base/base_cache_pool.py
@@ -1,6 +1,8 @@
 import base64
 from abc import ABC, abstractmethod
 from collections import defaultdict
+import sys
+import logging
 from typing import Any, Callable, DefaultDict, Dict, Final, List, Optional, Set, Tuple
 
 from meta_memcache.base.base_serializer import BaseSerializer
@@ -28,6 +30,8 @@ from meta_memcache.protocol import (
 )
 from meta_memcache.settings import MAX_KEY_SIZE
 
+_log: logging.Logger = logging.getLogger(__name__)
+
 
 class BaseCachePool(ABC):
     def __init__(
@@ -106,7 +110,7 @@ class BaseCachePool(ABC):
                     int_flags=int_flags,
                     token_flags=token_flags,
                 )
-                return self._conn_recv_response(conn, flags=flags)
+                return self._conn_recv_response(conn, flags=flags, key=key)
         except MemcacheServerError:
             if self._write_failure_tracker:
                 if command in (MetaCommand.META_DELETE, MetaCommand.META_SET):
@@ -147,7 +151,9 @@ class BaseCachePool(ABC):
                             token_flags=token_flags,
                         )
                     for key in pool_keys:
-                        results[key] = self._conn_recv_response(conn, flags=flags)
+                        results[key] = self._conn_recv_response(
+                            conn, flags=flags, key=key
+                        )
         except MemcacheServerError:
             if self._write_failure_tracker and command in (
                 MetaCommand.META_DELETE,
@@ -188,6 +194,7 @@ class BaseCachePool(ABC):
             and Flag.NOREPLY in flags
         )
 
+        # print(">>>", cmd)
         if value:
             conn.sendall(cmd + value + ENDL, with_noop=with_noop)
         else:
@@ -197,6 +204,7 @@ class BaseCachePool(ABC):
         self,
         conn: MemcacheSocket,
         flags: Optional[Set[Flag]] = None,
+        key="",
     ) -> MemcacheResponse:
         """
         Read response on a connection
@@ -204,12 +212,22 @@ class BaseCachePool(ABC):
         if flags and Flag.NOREPLY in flags:
             return Success(flags=set([Flag.NOREPLY]))
         result = conn.get_response()
+        # print("<<<", key, result)
         if isinstance(result, Value):
-            # TODO: Confirm this works for empty values!
             data = conn.get_value(result.size)
+            # print("<<<", key, f"Value size {result.size}", data)
             if result.size > 0:
                 encoding_id = result.int_flags.get(IntFlag.CLIENT_FLAG, 0)
-                result.value = self._serializer.unserialize(data, encoding_id)
+                try:
+                    result.value = self._serializer.unserialize(data, encoding_id)
+                except Exception as e:
+
+                    print(f"***", key, "*************** Error unserializing: {e}")
+                    print(type(data))
+                    print(bytes(data))
+                    sys.exit()
+                    result = Miss()
+
         return result
 
     def meta_multiget(
diff --git a/src/meta_memcache/base/cache_pool.py b/src/meta_memcache/base/cache_pool.py
index 4032b99..a254f84 100644
--- a/src/meta_memcache/base/cache_pool.py
+++ b/src/meta_memcache/base/cache_pool.py
@@ -223,10 +223,13 @@ class CachePool(BaseCachePool):
                 if Flag.WIN in result.flags:
                     # Win flag present, meaning we got the lease to
                     # recache the item. We need to mimic a miss.
+                    print(f"<<< Key {key} WIN -> MISS")
                     results[key] = None
                 else:
+                    print(f"<<< Key {key} got value")
                     results[key] = result.value
             elif isinstance(result, Miss):
+                print(f"<<< Key {key} is MISS")
                 results[key] = None
             else:
                 raise MemcacheError(f"Unexpected response: {result} for key {key}")
diff --git a/src/meta_memcache/base/memcache_socket.py b/src/meta_memcache/base/memcache_socket.py
index 578bdca..05b3d4d 100644
--- a/src/meta_memcache/base/memcache_socket.py
+++ b/src/meta_memcache/base/memcache_socket.py
@@ -1,5 +1,7 @@
 import logging
+from re import A
 import socket
+import sys
 from typing import Iterable, List, Union
 
 from meta_memcache.errors import MemcacheError
@@ -64,6 +66,8 @@ class MemcacheSocket:
     ) -> None:
         self.set_socket(conn)
         self._buffer_size = buffer_size
+        self._recv_buffer_size = buffer_size
+        conn.setsockopt(socket.SOL_SOCKET, socket.SO_RCVBUF, self._recv_buffer_size)
         self._version = version
         self._store_success_response_header: bytes = get_store_success_response_header(
             version
@@ -71,6 +75,7 @@ class MemcacheSocket:
         self._buf = bytearray(self._buffer_size)
         self._buf_view = memoryview(self._buf)
         self._noop_expected = 0
+        self._endl_buf = bytearray(ENDL_LEN)
 
     def __str__(self) -> str:
         return f"<MemcacheSocket {self._conn.fileno()}>"
@@ -93,56 +98,122 @@ class MemcacheSocket:
 
     def _recv_info_buffer(self) -> int:
         read = self._conn.recv_into(self._buf_view[self._read :])
-        self._read += read
+        if read > 0:
+            self._read += read
         return read
 
-    def _recv_endl_terminated_data(self, sized_buf: memoryview) -> int:
-        """
-        Received data into the given buffer. The size of the
-        buffer has to be exactly the expected data size.
-
-        The data in the socket has a termination mark (\r\n)
-        that has to be read too. To avoid having to slice
-        the data and cause yet another memory copy, we are
-        using recvmsg and providing a separate, fixed size
-        buffer for the termination mark.
-        """
-        msg_termination_buf = bytearray(ENDL_LEN)
-        read: int = self._conn.recvmsg_into(
-            [sized_buf, memoryview(msg_termination_buf)], 0, socket.MSG_WAITALL
-        )
-        if read != len(sized_buf) + ENDL_LEN or msg_termination_buf != ENDL:
-            raise MemcacheError(
-                f"Error parsing value: Expected {len(sized_buf)+ENDL_LEN} bytes, "
-                f"terminated in \\r\\n, got {read} bytes: "
-                f"{bytes(sized_buf)+bytes(msg_termination_buf)!r}"
-            )
-        return read - ENDL_LEN
+    def _recv_fill_buffer(self, buffer: memoryview) -> int:
+        read = 0
+        size = len(buffer)
+        while read < size:
+            read += self._conn.recv_into(buffer[read:], size - read, socket.MSG_WAITALL)
+            # a = self._conn.recv_into(buffer[read:], size - read, socket.MSG_WAITALL)
+            # read += a
+            # print("***", f"Read {a}, {read}/{size}")
+        return read
+
+        # def _recv_endl_terminated_data(self, sized_buf: memoryview) -> int:
+        #     """
+        #     Received data into the given buffer. The size of the
+        #     buffer has to be exactly the expected data size.
+
+        #     The data in the socket has a termination mark (\r\n)
+        #     that has to be read too. To avoid having to slice
+        #     the data and cause yet another memory copy, we are
+        #     using recvmsg and providing a separate, fixed size
+        #     buffer for the termination mark.
+        #     """
+        #     read = 0
+        #     size = len(sized_buf)
+        #     while read < size:
+        #         a = self._conn.recv_into(sized_buf[read:], size - read, socket.MSG_WAITALL)
+        #         read += a
+        #         # print("***", f"Read {a}, {read}/{size}")
+        #     read += self._conn.recv_into(memoryview(self._endl_buf), 2, socket.MSG_WAITALL)
+        #     if read != size + ENDL_LEN or self._endl_buf != ENDL:
+        #         print(
+        #             "***",
+        #             f"Error parsing value: Expected {len(sized_buf)+ENDL_LEN} bytes, "
+        #             f"terminated in \\r\\n, got {read} bytes: "
+        #             f"{bytes(sized_buf)+bytes(self._endl_buf)!r}",
+        #         )
+        #         raise MemcacheError(
+        #             f"Error parsing value: Expected {len(sized_buf)+ENDL_LEN} bytes, "
+        #             f"terminated in \\r\\n, got {read} bytes: "
+        #             f"{bytes(sized_buf)+bytes(self._endl_buf)!r}"
+        #         )
+        #     return size
+
+        # data_size = len(sized_buf) + ENDL_LEN
+        # if self._recv_buffer_size < data_size:
+        #     self._recv_buffer_size = data_size
+        #     self._conn.setsockopt(
+        #         socket.SOL_SOCKET, socket.SO_RCVBUF, self._recv_buffer_size
+        #     )
+        # endl_buf = bytearray(ENDL_LEN)
+        # read, _ancdata, _msg_flags, _address = self._conn.recvmsg_into(
+        #     [sized_buf, memoryview(endl_buf)], 0, socket.MSG_WAITALL
+        # )
+        # if read != data_size or endl_buf != ENDL:
+        #     raise MemcacheError(
+        #         f"Error parsing value: Expected {len(sized_buf)+ENDL_LEN} bytes, "
+        #         f"terminated in \\r\\n, got {read} bytes: "
+        #         f"{bytes(sized_buf)+bytes(endl_buf)!r}"
+        #     )
+        # return read - ENDL_LEN
 
     def _reset_buffer(self) -> None:
         """
         Reset buffer moving remaining bytes in it (if any)
         """
         remaining_data = self._read - self._pos
-        if remaining_data:
-            if self._pos <= self._buffer_size // 2:
+        if remaining_data > 0:
+            if self._pos <= 3900:  # self._buffer_size // 2:
                 # Avoid moving memory if buffer still has
                 # spare capacity for new responses. If the
                 # whole buffer us used, we will just reset
                 # the pointers and save a lot of memory
                 # data copies
+                # print("***", f"Not reset {self._pos} / {self._buffer_size}")
                 return
+            # print(
+            #     f"*** Reset buffer, copying {remaining_data} ({self._pos} .. {self._read}) -> (0 ... {remaining_data})"
+            # )
             # pyre-ignore[6]
-            self._buf_view[0:remaining_data] = self._buf_view[self._pos : self._read]
+            self._buf_view[0:remaining_data] = bytes(
+                self._buf_view[self._pos : self._read]
+            )
+            self._read = remaining_data
+        else:
+            # print("***", f"Clean reset buffer, pos=0, read={remaining_data}")
+            self._read = 0
         self._pos = 0
-        self._read = remaining_data
 
     def _recv_header(self) -> int:
+        endl_pos = self._buf.find(ENDL, self._pos, self._read)
+        # print(
+        #     "PEEK", bytes(self._buf_view[self._pos : min(self._pos + 50, self._read)])
+        # )
+        # print("ENDL", endl_pos)
+        while endl_pos < 0 and self._read < self._buffer_size:
+            # Missing data, but still space in buffer, so read more
+            self._recv_info_buffer()
+            endl_pos = self._buf.find(ENDL, self._pos, self._read)
+            # print(
+            #     "PEEK",
+            #     bytes(self._buf_view[self._pos : min(self._pos + 50, self._read)]),
+            # )
+            # print("ENDL", endl_pos)
+
+        return endl_pos
         if self._read - self._pos < MIN_HEADER_SIZE:
             # No response in buffer
             self._recv_info_buffer()
 
-        endl_pos = self._buf.find(ENDL, self._pos, self._read)
+        # print(
+        #     "PEEK", bytes(self._buf_view[self._pos : min(self._pos + 50, self._read)])
+        # )
+        # print("ENDL", endl_pos)
         if endl_pos < 0:
             # No ENDL found in buffer
             old_read = self._read
@@ -195,8 +266,11 @@ class MemcacheSocket:
         return chunks
 
     def _get_single_header(self) -> List[memoryview]:
+        # print("***", "Reset on header")
+        self._reset_buffer()
         endl_pos = self._recv_header()
         header = self._buf_view[self._pos : endl_pos]
+        # print("HEADER", bytes(header))
         self._pos = endl_pos + ENDL_LEN
         return self._tokenize_header(header)
 
@@ -226,6 +300,7 @@ class MemcacheSocket:
         self,
     ) -> Union[Value, Success, NotStored, Conflict, Miss]:
         header = self._get_header()
+        # print(b" ".join([bytes(x) for x in header]))
         try:
             response_code, *chunks = header
             if response_code == b"VA":
@@ -257,7 +332,6 @@ class MemcacheSocket:
             _log.exception(f"Error parsing response header in {self}: {response}")
             raise MemcacheError(f"Error parsing response header {response}") from e
 
-        self._reset_buffer()
         return result
 
     def get_value(self, size: int) -> Union[bytearray, memoryview]:
@@ -265,51 +339,128 @@ class MemcacheSocket:
         Get data value from the buffer and/or socket if hasn't been
         read fully.
         """
+        message_size = size + ENDL_LEN
         data_in_buf = self._read - self._pos
-        missing_data_size = size - data_in_buf
-        if missing_data_size > 0 and self._read < len(self._buf):
+        while data_in_buf < message_size and self._read < self._buffer_size:
             # Missing data, but still space in buffer, so read more
             self._recv_info_buffer()
+            data_in_buf = self._read - self._pos
 
-        data_in_buf = self._read - self._pos
-        missing_data_size = size - data_in_buf
-        if missing_data_size > 0:
-            # Value is greater than buffer:
-            # - generate new bytearray of the total size
-            # - copy data in buffer into new bytearray
-            # - read the remaining data from socket and combine it
-            data = bytearray(size)
-            view = memoryview(data)
-            # pyre-ignore[6]
-            view[:data_in_buf] = self._buf_view[self._pos : self._read]
-            read = self._recv_endl_terminated_data(view[data_in_buf:])
-            if size != data_in_buf + read:
-                raise MemcacheError(
-                    f"Error parsing value. Expected {size} bytes, "
-                    f"got {data_in_buf}+{read}"
-                )
-            # The whole buffer was used
-            self._pos = self._read
-        else:
+        if data_in_buf >= size:
             # Value is within buffer, slice it
             data_end = self._pos + size
             data = self._buf_view[self._pos : data_end]
-            # Advance pos to data end
-            self._pos = data_end
-            # Ensure the data is correctly terminated
-            if self._read < self._pos + ENDL_LEN:
-                # the buffer ended half-way the ENDL termination
-                # message, we need to read more from the wire.
-                self._reset_buffer()
-                self._recv_info_buffer()
-                assert self._read >= self._pos + ENDL_LEN  # noqa: S101
-            if self._buf_view[self._pos : self._pos + ENDL_LEN] != ENDL:
-                raise MemcacheError("Error parsing value. Data doesn't end in \\r\\n")
-            self._pos += ENDL_LEN
-
-        self._reset_buffer()
-        if len(data) != size:
+            if data_in_buf >= size + ENDL_LEN:
+                # ENDL is also within buffer, slice it
+                endl = self._buf_view[data_end : data_end + ENDL_LEN]
+            else:
+                # ENDL ended half-way at the end of the buffer.
+                endl = memoryview(self._endl_buf)
+                # Copy data in the local buffer
+                # pyre-ignore[6]
+                # print("self._read", self._read)
+                # print("data_end", data_end)
+                endl_in_buf = data_in_buf - size
+                # print(f"endl[0:{endl_in_buf}] <- bug[{data_end}:{self._read}]")
+                # print(bytes(self._endl_buf))
+                endl[0:endl_in_buf] = self._buf_view[data_end:]
+                # Read the rest
+                self._recv_fill_buffer(endl[endl_in_buf:])
+        else:
+            message = bytearray(size + ENDL_LEN)
+            message_view = memoryview(message)
+            # Copy data in the local buffer to the new allocated buffer
+            # pyre-ignore[6]
+            message_view[:data_in_buf] = self._buf_view[self._pos : self._read]
+            # Read the rest
+            self._recv_fill_buffer(message_view[data_in_buf:])
+            data = message_view[:size]
+            endl = message_view[size:]
+
+        self._pos = min(self._pos + message_size, self._read)
+
+        if len(data) != size or endl != ENDL:
+            print(
+                "***",
+                f"Error parsing value: Expected {size} bytes, "
+                f"terminated in \\r\\n, got {len(data)} bytes: "
+                f"{bytes(data)+bytes(endl)!r}",
+            )
             raise MemcacheError(
-                f"Error parsing value. Expected {size} bytes, got {len(data)}"
+                f"Error parsing value: Expected {size} bytes, "
+                f"terminated in \\r\\n, got {len(data)} bytes: "
+                f"{bytes(data)+bytes(endl)!r}",
             )
+            sys.exit()
         return data
+
+        # data_in_buf = self._read - self._pos
+        # data_in_buf
+
+        # if missing_data_size > 0:
+        #     print(f"Missing data: {missing_data_size}")
+        #     # Value is greater than buffer:
+        #     # - generate new bytearray of the total size
+        #     # - copy data in buffer into new bytearray
+        #     # - read the remaining data from socket and combine it
+        #     if data_in_buf >= size:
+        #         # The buffer ended half-way the ENDL termination
+        #         # message, but the data was read in full.
+        #         # Value is within buffer, slice it
+        #         data_end = self._pos + size
+        #         data = self._buf_view[self._pos : data_end]
+        #         endl_buf = memoryview(self._endl_buf)
+        #     else:
+        #         data = bytearray(size)
+        #         view = memoryview(data)
+        #         # pyre-ignore[6]
+        #         view[:data_in_buf] = self._buf_view[self._pos : self._read]
+        #         read = self._recv_endl_terminated_data(view[data_in_buf:])
+
+        #     # The whole buffer was used
+        #     self._pos = self._read
+
+        #     data = bytearray(size)
+        #     view = memoryview(data)
+        #     # pyre-ignore[6]
+        #     view[:data_in_buf] = self._buf_view[self._pos : self._read]
+        #     read = self._recv_endl_terminated_data(view[data_in_buf:])
+        #     if size != data_in_buf + read:
+        #         raise MemcacheError(
+        #             f"Error parsing value. Expected {size} bytes, "
+        #             f"got {data_in_buf}+{read}"
+        #         )
+        #     # The whole buffer was used
+        #     self._pos = self._read
+        # else:
+
+        #     if data_in_buf < size + ENDL_LEN:
+        #         self.endl_buf
+
+        # else:
+        #     # Value is within buffer, slice it
+        #     data_end = self._pos + size
+        #     data = self._buf_view[self._pos : data_end]
+        #     # Advance pos to data end
+        #     self._pos = data_end
+        #     # Ensure the data is correctly terminated
+        #     if self._read < self._pos + ENDL_LEN:
+        #         print("***", "Buffer half way ENDL")
+        #         # Copy the data before resetting the buffer
+        #         # or the memory view contents will change.
+        #         data = bytes(data)
+        #         self._reset_buffer()
+        #         print("***", "Reset on get value half way ENDL")
+        #         self._recv_info_buffer()
+        #         assert self._read >= self._pos + ENDL_LEN  # noqa: S101
+        #     if self._buf_view[self._pos : self._pos + ENDL_LEN] != ENDL:
+        #         raise MemcacheError("Error parsing value. Data doesn't end in \\r\\n")
+        #     self._pos += ENDL_LEN
+
+        # # self._reset_buffer()
+        # # print("***", "Reset on get value at the end")
+        # if len(data) != size:
+        #     raise MemcacheError(
+        #         f"Error parsing value. Expected {size} bytes, got {len(data)}"
+        #     )
+        # return data
