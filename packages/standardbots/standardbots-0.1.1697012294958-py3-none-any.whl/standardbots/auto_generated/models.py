# Code autogenerated by StandardBots

from dataclasses import dataclass
from typing import List, Tuple, Union
from enum import Enum

def parse_float(data: object) -> float:
  return float(data)

def parse_int(data: object) -> int:
  return int(data)

def parse_bool(data: object) -> bool:
  return bool(data)

def parse_str(data: object) -> str:
  return str(data)

def serialize_float(data: float) -> object:
  return data

def serialize_int(data: int) -> object:
  return data

def serialize_bool(data: bool) -> object:
  return data

def serialize_str(data: str) -> object:
  return data

@dataclass
class RoutineEnvironmentVariablesEnvironmentVariables:
  id: Union[str, None] = None
  name: Union[str, None] = None

  def __post_init__(self):
    # Type check incoming model - raise error if invalid (required or wrong type)
    if not (self.id is None or isinstance(self.id, str)):
      raise TypeError("id must be of type str for RoutineEnvironmentVariablesEnvironmentVariables, got " + type(self.id).__name__)
    if not (self.name is None or isinstance(self.name, str)):
      raise TypeError("name must be of type str for RoutineEnvironmentVariablesEnvironmentVariables, got " + type(self.name).__name__)

def parse_routine_environment_variables_environment_variables(data: object):
  return RoutineEnvironmentVariablesEnvironmentVariables(
    id=parse_str(data["id"]) if "id" in data else None,
    name=parse_str(data["name"]) if "name" in data else None,
  )

def serialize_routine_environment_variables_environment_variables(data: RoutineEnvironmentVariablesEnvironmentVariables) -> object:
  return {
    "id": None if data.id is None else serialize_str(data.id),
    "name": None if data.name is None else serialize_str(data.name),
  }

RoutineEnvironmentVariables = List[RoutineEnvironmentVariablesEnvironmentVariables]

def parse_routine_environment_variables(data: object) -> RoutineEnvironmentVariables:
  return [parse_routine_environment_variables_environment_variables(item) for item in data]

def serialize_routine_environment_variables(data: RoutineEnvironmentVariables) -> List[object]:
  return [serialize_routine_environment_variables_environment_variables(item) for item in data]

@dataclass
class Routine:
  """Robot Routine containing steps to automate robot movement and operations"""
  id: Union[str, None] = None
  name: Union[str, None] = None
  environmentVariables: Union[RoutineEnvironmentVariables, None] = None

  def __post_init__(self):
    # Type check incoming model - raise error if invalid (required or wrong type)
    if not (self.id is None or isinstance(self.id, str)):
      raise TypeError("id must be of type str for Routine, got " + type(self.id).__name__)
    if not (self.name is None or isinstance(self.name, str)):
      raise TypeError("name must be of type str for Routine, got " + type(self.name).__name__)
    if not (self.environmentVariables is None or isinstance(self.environmentVariables, list)):
      raise TypeError("environmentVariables must be of type list for Routine, got " + type(self.environmentVariables).__name__)

def parse_routine(data: object):
  return Routine(
    id=parse_str(data["id"]) if "id" in data else None,
    name=parse_str(data["name"]) if "name" in data else None,
    environmentVariables=parse_routine_environment_variables(data["environmentVariables"]) if "environmentVariables" in data else None,
  )

def serialize_routine(data: Routine) -> object:
  return {
    "id": None if data.id is None else serialize_str(data.id),
    "name": None if data.name is None else serialize_str(data.name),
    "environmentVariables": None if data.environmentVariables is None else serialize_routine_environment_variables(data.environmentVariables),
  }

RoutinesPaginatedResponseItems = List[Routine]

def parse_routines_paginated_response_items(data: object) -> RoutinesPaginatedResponseItems:
  return [parse_routine(item) for item in data]

def serialize_routines_paginated_response_items(data: RoutinesPaginatedResponseItems) -> List[object]:
  return [serialize_routine(item) for item in data]

@dataclass
class RoutinesPaginatedResponse:
  items: Union[RoutinesPaginatedResponseItems, None] = None
  total: Union[int, None] = None

  def __post_init__(self):
    # Type check incoming model - raise error if invalid (required or wrong type)
    if not (self.items is None or isinstance(self.items, list)):
      raise TypeError("items must be of type list for RoutinesPaginatedResponse, got " + type(self.items).__name__)
    if not (self.total is None or isinstance(self.total, int)):
      raise TypeError("total must be of type int for RoutinesPaginatedResponse, got " + type(self.total).__name__)

def parse_routines_paginated_response(data: object):
  return RoutinesPaginatedResponse(
    items=parse_routines_paginated_response_items(data["items"]) if "items" in data else None,
    total=parse_int(data["total"]) if "total" in data else None,
  )

def serialize_routines_paginated_response(data: RoutinesPaginatedResponse) -> object:
  return {
    "items": None if data.items is None else serialize_routines_paginated_response_items(data.items),
    "total": None if data.total is None else serialize_int(data.total),
  }

class StatusHealthResponseStatus(Enum):
  Ok = "ok"
  Warning = "warning"
  Error = "error"

def parse_status_health_response_status(data: object) -> StatusHealthResponseStatus:
  return StatusHealthResponseStatus(data)

def serialize_status_health_response_status(data: Union[StatusHealthResponseStatus, str]) -> object:
  return StatusHealthResponseStatus(data).value

@dataclass
class StatusHealthResponse:
  """Status Health Response"""
  status: StatusHealthResponseStatus

  def __post_init__(self):
    # Type check incoming model - raise error if invalid (required or wrong type)
    if self.status is None:
      raise ValueError("status is required for StatusHealthResponse")
    if not isinstance(self.status, StatusHealthResponseStatus):
      raise TypeError("status must be of type StatusHealthResponseStatus for StatusHealthResponse, got " + type(self.status).__name__)

def parse_status_health_response(data: object):
  return StatusHealthResponse(
    status=parse_status_health_response_status(data["status"]),
  )

def serialize_status_health_response(data: StatusHealthResponse) -> object:
  return {
    "status": serialize_status_health_response_status(data.status),
  }

class ErrorResponseCode(Enum):
  AuthorizationRequired = "authorization_required"
  RoutineMustBeRunning = "routine_must_be_running"
  ApiControlRequired = "api_control_required"
  RobotBrakesDisengageFailed = "robot_brakes_disengage_failed"
  RobotBrakesEngageFailed = "robot_brakes_engage_failed"
  RequestFailedValidation = "request_failed_validation"
  BrakesMustBeEngaged = "brakes_must_be_engaged"
  BrakesMustBeDisengaged = "brakes_must_be_disengaged"

def parse_error_response_code(data: object) -> ErrorResponseCode:
  return ErrorResponseCode(data)

def serialize_error_response_code(data: Union[ErrorResponseCode, str]) -> object:
  return ErrorResponseCode(data).value

@dataclass
class ErrorResponse:
  """Error Response"""
  code: ErrorResponseCode
  message: str

  def __post_init__(self):
    # Type check incoming model - raise error if invalid (required or wrong type)
    if self.code is None:
      raise ValueError("code is required for ErrorResponse")
    if not isinstance(self.code, ErrorResponseCode):
      raise TypeError("code must be of type ErrorResponseCode for ErrorResponse, got " + type(self.code).__name__)
    if self.message is None:
      raise ValueError("message is required for ErrorResponse")
    if not isinstance(self.message, str):
      raise TypeError("message must be of type str for ErrorResponse, got " + type(self.message).__name__)

def parse_error_response(data: object):
  return ErrorResponse(
    code=parse_error_response_code(data["code"]),
    message=parse_str(data["message"]),
  )

def serialize_error_response(data: ErrorResponse) -> object:
  return {
    "code": serialize_error_response_code(data.code),
    "message": serialize_str(data.message),
  }

class ArmPositionUpdateEventKind(Enum):
  Success = "success"
  Failure = "failure"
  Canceled = "canceled"
  Position = "position"
  Planning = "planning"

def parse_arm_position_update_event_kind(data: object) -> ArmPositionUpdateEventKind:
  return ArmPositionUpdateEventKind(data)

def serialize_arm_position_update_event_kind(data: Union[ArmPositionUpdateEventKind, str]) -> object:
  return ArmPositionUpdateEventKind(data).value

class ArmPositionUpdateFailureEventCode(Enum):
  MotionFailedUnknownReason = "motion_failed_unknown_reason"
  MotionFailedCollision = "motion_failed_collision"

def parse_arm_position_update_failure_event_code(data: object) -> ArmPositionUpdateFailureEventCode:
  return ArmPositionUpdateFailureEventCode(data)

def serialize_arm_position_update_failure_event_code(data: Union[ArmPositionUpdateFailureEventCode, str]) -> object:
  return ArmPositionUpdateFailureEventCode(data).value

@dataclass
class ArmPositionUpdateFailureEvent:
  """Move robot event when movement failed"""
  code: ArmPositionUpdateFailureEventCode
  reason: str

  def __post_init__(self):
    # Type check incoming model - raise error if invalid (required or wrong type)
    if self.code is None:
      raise ValueError("code is required for ArmPositionUpdateFailureEvent")
    if not isinstance(self.code, ArmPositionUpdateFailureEventCode):
      raise TypeError("code must be of type ArmPositionUpdateFailureEventCode for ArmPositionUpdateFailureEvent, got " + type(self.code).__name__)
    if self.reason is None:
      raise ValueError("reason is required for ArmPositionUpdateFailureEvent")
    if not isinstance(self.reason, str):
      raise TypeError("reason must be of type str for ArmPositionUpdateFailureEvent, got " + type(self.reason).__name__)

def parse_arm_position_update_failure_event(data: object):
  return ArmPositionUpdateFailureEvent(
    code=parse_arm_position_update_failure_event_code(data["code"]),
    reason=parse_str(data["reason"]),
  )

def serialize_arm_position_update_failure_event(data: ArmPositionUpdateFailureEvent) -> object:
  return {
    "code": serialize_arm_position_update_failure_event_code(data.code),
    "reason": serialize_str(data.reason),
  }

@dataclass
class ArmPositionUpdateCanceledEvent:
  """Move robot event when motion is canceled"""
  code: Union[str, None] = None
  reason: Union[str, None] = None

  def __post_init__(self):
    # Type check incoming model - raise error if invalid (required or wrong type)
    if not (self.code is None or isinstance(self.code, str)):
      raise TypeError("code must be of type str for ArmPositionUpdateCanceledEvent, got " + type(self.code).__name__)
    if not (self.reason is None or isinstance(self.reason, str)):
      raise TypeError("reason must be of type str for ArmPositionUpdateCanceledEvent, got " + type(self.reason).__name__)

def parse_arm_position_update_canceled_event(data: object):
  return ArmPositionUpdateCanceledEvent(
    code=parse_str(data["code"]) if "code" in data else None,
    reason=parse_str(data["reason"]) if "reason" in data else None,
  )

def serialize_arm_position_update_canceled_event(data: ArmPositionUpdateCanceledEvent) -> object:
  return {
    "code": None if data.code is None else serialize_str(data.code),
    "reason": None if data.reason is None else serialize_str(data.reason),
  }

JointRotations = Tuple[float,float,float,float,float,float,]

def parse_joint_rotations(data: object) -> JointRotations:
  return (parse_float(data[0]),parse_float(data[1]),parse_float(data[2]),parse_float(data[3]),parse_float(data[4]),parse_float(data[5]),)

def serialize_joint_rotations(data: JointRotations) -> object:
  return [serialize_float(data[0]),serialize_float(data[1]),serialize_float(data[2]),serialize_float(data[3]),serialize_float(data[4]),serialize_float(data[5]),]

class PositionUnitKind(Enum):
  Millimeters = "millimeters"
  Centimeters = "centimeters"
  Meters = "meters"
  Inches = "inches"
  Feet = "feet"

def parse_position_unit_kind(data: object) -> PositionUnitKind:
  return PositionUnitKind(data)

def serialize_position_unit_kind(data: Union[PositionUnitKind, str]) -> object:
  return PositionUnitKind(data).value

@dataclass
class Position:
  """Position of an object in 3D space"""
  x: float
  y: float
  z: float
  unit_kind: Union[PositionUnitKind, None] = None

  def __post_init__(self):
    # Type check incoming model - raise error if invalid (required or wrong type)
    if self.x is None:
      raise ValueError("x is required for Position")
    if not isinstance(self.x, float):
      raise TypeError("x must be of type float for Position, got " + type(self.x).__name__)
    if self.y is None:
      raise ValueError("y is required for Position")
    if not isinstance(self.y, float):
      raise TypeError("y must be of type float for Position, got " + type(self.y).__name__)
    if self.z is None:
      raise ValueError("z is required for Position")
    if not isinstance(self.z, float):
      raise TypeError("z must be of type float for Position, got " + type(self.z).__name__)
    if not (self.unit_kind is None or isinstance(self.unit_kind, PositionUnitKind)):
      raise TypeError("unit_kind must be of type PositionUnitKind for Position, got " + type(self.unit_kind).__name__)

def parse_position(data: object):
  return Position(
    x=parse_float(data["x"]),
    y=parse_float(data["y"]),
    z=parse_float(data["z"]),
    unit_kind=parse_position_unit_kind(data["unit_kind"]) if "unit_kind" in data else None,
  )

def serialize_position(data: Position) -> object:
  return {
    "x": serialize_float(data.x),
    "y": serialize_float(data.y),
    "z": serialize_float(data.z),
    "unit_kind": None if data.unit_kind is None else serialize_position_unit_kind(data.unit_kind),
  }

class OrientationKind(Enum):
  Quaternion = "quaternion"

def parse_orientation_kind(data: object) -> OrientationKind:
  return OrientationKind(data)

def serialize_orientation_kind(data: Union[OrientationKind, str]) -> object:
  return OrientationKind(data).value

@dataclass
class OrientationQuaternion:
  x: float
  y: float
  z: float
  w: float

  def __post_init__(self):
    # Type check incoming model - raise error if invalid (required or wrong type)
    if self.x is None:
      raise ValueError("x is required for OrientationQuaternion")
    if not isinstance(self.x, float):
      raise TypeError("x must be of type float for OrientationQuaternion, got " + type(self.x).__name__)
    if self.y is None:
      raise ValueError("y is required for OrientationQuaternion")
    if not isinstance(self.y, float):
      raise TypeError("y must be of type float for OrientationQuaternion, got " + type(self.y).__name__)
    if self.z is None:
      raise ValueError("z is required for OrientationQuaternion")
    if not isinstance(self.z, float):
      raise TypeError("z must be of type float for OrientationQuaternion, got " + type(self.z).__name__)
    if self.w is None:
      raise ValueError("w is required for OrientationQuaternion")
    if not isinstance(self.w, float):
      raise TypeError("w must be of type float for OrientationQuaternion, got " + type(self.w).__name__)

def parse_orientation_quaternion(data: object):
  return OrientationQuaternion(
    x=parse_float(data["x"]),
    y=parse_float(data["y"]),
    z=parse_float(data["z"]),
    w=parse_float(data["w"]),
  )

def serialize_orientation_quaternion(data: OrientationQuaternion) -> object:
  return {
    "x": serialize_float(data.x),
    "y": serialize_float(data.y),
    "z": serialize_float(data.z),
    "w": serialize_float(data.w),
  }

@dataclass
class Orientation:
  """Orientation of an object in 3D space"""
  kind: OrientationKind
  quaternion: Union[OrientationQuaternion, None] = None

  def __post_init__(self):
    # Type check incoming model - raise error if invalid (required or wrong type)
    if self.kind is None:
      raise ValueError("kind is required for Orientation")
    if not isinstance(self.kind, OrientationKind):
      raise TypeError("kind must be of type OrientationKind for Orientation, got " + type(self.kind).__name__)
    if not (self.quaternion is None or isinstance(self.quaternion, OrientationQuaternion)):
      raise TypeError("quaternion must be of type OrientationQuaternion for Orientation, got " + type(self.quaternion).__name__)

def parse_orientation(data: object):
  return Orientation(
    kind=parse_orientation_kind(data["kind"]),
    quaternion=parse_orientation_quaternion(data["quaternion"]) if "quaternion" in data else None,
  )

def serialize_orientation(data: Orientation) -> object:
  return {
    "kind": serialize_orientation_kind(data.kind),
    "quaternion": None if data.quaternion is None else serialize_orientation_quaternion(data.quaternion),
  }

class PositionAndOrientationAxisAlignment(Enum):
  Base = "base"
  Tooltip = "tooltip"

def parse_position_and_orientation_axis_alignment(data: object) -> PositionAndOrientationAxisAlignment:
  return PositionAndOrientationAxisAlignment(data)

def serialize_position_and_orientation_axis_alignment(data: Union[PositionAndOrientationAxisAlignment, str]) -> object:
  return PositionAndOrientationAxisAlignment(data).value

@dataclass
class PositionAndOrientation:
  """Position of the arm tooltip"""
  position: Position
  orientation: Orientation
  axis_alignment: Union[PositionAndOrientationAxisAlignment, None] = None
  reference_frame: Union[str, None] = None

  def __post_init__(self):
    # Type check incoming model - raise error if invalid (required or wrong type)
    if self.position is None:
      raise ValueError("position is required for PositionAndOrientation")
    if not isinstance(self.position, Position):
      raise TypeError("position must be of type Position for PositionAndOrientation, got " + type(self.position).__name__)
    if self.orientation is None:
      raise ValueError("orientation is required for PositionAndOrientation")
    if not isinstance(self.orientation, Orientation):
      raise TypeError("orientation must be of type Orientation for PositionAndOrientation, got " + type(self.orientation).__name__)
    if not (self.axis_alignment is None or isinstance(self.axis_alignment, PositionAndOrientationAxisAlignment)):
      raise TypeError("axis_alignment must be of type PositionAndOrientationAxisAlignment for PositionAndOrientation, got " + type(self.axis_alignment).__name__)
    if not (self.reference_frame is None or isinstance(self.reference_frame, str)):
      raise TypeError("reference_frame must be of type str for PositionAndOrientation, got " + type(self.reference_frame).__name__)

def parse_position_and_orientation(data: object):
  return PositionAndOrientation(
    position=parse_position(data["position"]),
    orientation=parse_orientation(data["orientation"]),
    axis_alignment=parse_position_and_orientation_axis_alignment(data["axis_alignment"]) if "axis_alignment" in data else None,
    reference_frame=parse_str(data["reference_frame"]) if "reference_frame" in data else None,
  )

def serialize_position_and_orientation(data: PositionAndOrientation) -> object:
  return {
    "position": serialize_position(data.position),
    "orientation": serialize_orientation(data.orientation),
    "axis_alignment": None if data.axis_alignment is None else serialize_position_and_orientation_axis_alignment(data.axis_alignment),
    "reference_frame": None if data.reference_frame is None else serialize_str(data.reference_frame),
  }

@dataclass
class CombinedArmPosition:
  joint_rotations: JointRotations
  tooltip_position: PositionAndOrientation

  def __post_init__(self):
    # Type check incoming model - raise error if invalid (required or wrong type)
    if self.joint_rotations is None:
      raise ValueError("joint_rotations is required for CombinedArmPosition")
    if not isinstance(self.joint_rotations, tuple):
      raise TypeError("joint_rotations must be of type tuple for CombinedArmPosition, got " + type(self.joint_rotations).__name__)
    if self.tooltip_position is None:
      raise ValueError("tooltip_position is required for CombinedArmPosition")
    if not isinstance(self.tooltip_position, PositionAndOrientation):
      raise TypeError("tooltip_position must be of type PositionAndOrientation for CombinedArmPosition, got " + type(self.tooltip_position).__name__)

def parse_combined_arm_position(data: object):
  return CombinedArmPosition(
    joint_rotations=parse_joint_rotations(data["joint_rotations"]),
    tooltip_position=parse_position_and_orientation(data["tooltip_position"]),
  )

def serialize_combined_arm_position(data: CombinedArmPosition) -> object:
  return {
    "joint_rotations": serialize_joint_rotations(data.joint_rotations),
    "tooltip_position": serialize_position_and_orientation(data.tooltip_position),
  }

@dataclass
class ArmPositionUpdateEvent:
  """Event emitted by the move robot API"""
  kind: Union[ArmPositionUpdateEventKind, None] = None
  failure: Union[ArmPositionUpdateFailureEvent, None] = None
  canceled: Union[ArmPositionUpdateCanceledEvent, None] = None
  position: Union[CombinedArmPosition, None] = None

  def __post_init__(self):
    # Type check incoming model - raise error if invalid (required or wrong type)
    if not (self.kind is None or isinstance(self.kind, ArmPositionUpdateEventKind)):
      raise TypeError("kind must be of type ArmPositionUpdateEventKind for ArmPositionUpdateEvent, got " + type(self.kind).__name__)
    if not (self.failure is None or isinstance(self.failure, ArmPositionUpdateFailureEvent)):
      raise TypeError("failure must be of type ArmPositionUpdateFailureEvent for ArmPositionUpdateEvent, got " + type(self.failure).__name__)
    if not (self.canceled is None or isinstance(self.canceled, ArmPositionUpdateCanceledEvent)):
      raise TypeError("canceled must be of type ArmPositionUpdateCanceledEvent for ArmPositionUpdateEvent, got " + type(self.canceled).__name__)
    if not (self.position is None or isinstance(self.position, CombinedArmPosition)):
      raise TypeError("position must be of type CombinedArmPosition for ArmPositionUpdateEvent, got " + type(self.position).__name__)

def parse_arm_position_update_event(data: object):
  return ArmPositionUpdateEvent(
    kind=parse_arm_position_update_event_kind(data["kind"]) if "kind" in data else None,
    failure=parse_arm_position_update_failure_event(data["failure"]) if "failure" in data else None,
    canceled=parse_arm_position_update_canceled_event(data["canceled"]) if "canceled" in data else None,
    position=parse_combined_arm_position(data["position"]) if "position" in data else None,
  )

def serialize_arm_position_update_event(data: ArmPositionUpdateEvent) -> object:
  return {
    "kind": None if data.kind is None else serialize_arm_position_update_event_kind(data.kind),
    "failure": None if data.failure is None else serialize_arm_position_update_failure_event(data.failure),
    "canceled": None if data.canceled is None else serialize_arm_position_update_canceled_event(data.canceled),
    "position": None if data.position is None else serialize_combined_arm_position(data.position),
  }

ArmPositionUpdateEventStream = List[ArmPositionUpdateEvent]

def parse_arm_position_update_event_stream(data: object) -> ArmPositionUpdateEventStream:
  return [parse_arm_position_update_event(item) for item in data]

def serialize_arm_position_update_event_stream(data: ArmPositionUpdateEventStream) -> List[object]:
  return [serialize_arm_position_update_event(item) for item in data]

@dataclass
class EngageEmergencyStopRequest:
  """Engage Emergency Stop. This will immediately stop the robot and prevent it from moving until the robot is unbraked.
"""
  reason: Union[str, None] = None

  def __post_init__(self):
    # Type check incoming model - raise error if invalid (required or wrong type)
    if not (self.reason is None or isinstance(self.reason, str)):
      raise TypeError("reason must be of type str for EngageEmergencyStopRequest, got " + type(self.reason).__name__)

def parse_engage_emergency_stop_request(data: object):
  return EngageEmergencyStopRequest(
    reason=parse_str(data["reason"]) if "reason" in data else None,
  )

def serialize_engage_emergency_stop_request(data: EngageEmergencyStopRequest) -> object:
  return {
    "reason": None if data.reason is None else serialize_str(data.reason),
  }

class LinearUnitUnitKind(Enum):
  Millimeters = "millimeters"
  Centimeters = "centimeters"
  Meters = "meters"
  Inches = "inches"
  Feet = "feet"

def parse_linear_unit_unit_kind(data: object) -> LinearUnitUnitKind:
  return LinearUnitUnitKind(data)

def serialize_linear_unit_unit_kind(data: Union[LinearUnitUnitKind, str]) -> object:
  return LinearUnitUnitKind(data).value

@dataclass
class LinearUnit:
  """Reusable Abstraction for linear units (eg distance, position, offset)
"""
  unit_kind: LinearUnitUnitKind
  value: Union[float, None] = None

  def __post_init__(self):
    # Type check incoming model - raise error if invalid (required or wrong type)
    if self.unit_kind is None:
      raise ValueError("unit_kind is required for LinearUnit")
    if not isinstance(self.unit_kind, LinearUnitUnitKind):
      raise TypeError("unit_kind must be of type LinearUnitUnitKind for LinearUnit, got " + type(self.unit_kind).__name__)
    if not (self.value is None or isinstance(self.value, float)):
      raise TypeError("value must be of type float for LinearUnit, got " + type(self.value).__name__)

def parse_linear_unit(data: object):
  return LinearUnit(
    unit_kind=parse_linear_unit_unit_kind(data["unit_kind"]),
    value=parse_float(data["value"]) if "value" in data else None,
  )

def serialize_linear_unit(data: LinearUnit) -> object:
  return {
    "unit_kind": serialize_linear_unit_unit_kind(data.unit_kind),
    "value": None if data.value is None else serialize_float(data.value),
  }

class ForceUnitUnitKind(Enum):
  Newtons = "newtons"
  Pounds = "pounds"

def parse_force_unit_unit_kind(data: object) -> ForceUnitUnitKind:
  return ForceUnitUnitKind(data)

def serialize_force_unit_unit_kind(data: Union[ForceUnitUnitKind, str]) -> object:
  return ForceUnitUnitKind(data).value

@dataclass
class ForceUnit:
  """Reusable Abstraction for force units (eg force, torque)
"""
  unit_kind: ForceUnitUnitKind
  value: Union[float, None] = None

  def __post_init__(self):
    # Type check incoming model - raise error if invalid (required or wrong type)
    if self.unit_kind is None:
      raise ValueError("unit_kind is required for ForceUnit")
    if not isinstance(self.unit_kind, ForceUnitUnitKind):
      raise TypeError("unit_kind must be of type ForceUnitUnitKind for ForceUnit, got " + type(self.unit_kind).__name__)
    if not (self.value is None or isinstance(self.value, float)):
      raise TypeError("value must be of type float for ForceUnit, got " + type(self.value).__name__)

def parse_force_unit(data: object):
  return ForceUnit(
    unit_kind=parse_force_unit_unit_kind(data["unit_kind"]),
    value=parse_float(data["value"]) if "value" in data else None,
  )

def serialize_force_unit(data: ForceUnit) -> object:
  return {
    "unit_kind": serialize_force_unit_unit_kind(data.unit_kind),
    "value": None if data.value is None else serialize_float(data.value),
  }

class GripperCommandRequestKind(Enum):
  Onrobot2Fg7 = "onrobot_2fg7"
  Onrobot3Fg15 = "onrobot_3fg15"

def parse_gripper_command_request_kind(data: object) -> GripperCommandRequestKind:
  return GripperCommandRequestKind(data)

def serialize_gripper_command_request_kind(data: Union[GripperCommandRequestKind, str]) -> object:
  return GripperCommandRequestKind(data).value

class OnRobot2Fg7GripperCommandRequestGripDirection(Enum):
  Inward = "inward"
  Outward = "outward"

def parse_on_robot_2_fg_7_gripper_command_request_grip_direction(data: object) -> OnRobot2Fg7GripperCommandRequestGripDirection:
  return OnRobot2Fg7GripperCommandRequestGripDirection(data)

def serialize_on_robot_2_fg_7_gripper_command_request_grip_direction(data: Union[OnRobot2Fg7GripperCommandRequestGripDirection, str]) -> object:
  return OnRobot2Fg7GripperCommandRequestGripDirection(data).value

class OnRobot2Fg7GripperCommandRequestControlKind(Enum):
  Move = "move"
  ForceGrip = "force_grip"

def parse_on_robot_2_fg_7_gripper_command_request_control_kind(data: object) -> OnRobot2Fg7GripperCommandRequestControlKind:
  return OnRobot2Fg7GripperCommandRequestControlKind(data)

def serialize_on_robot_2_fg_7_gripper_command_request_control_kind(data: Union[OnRobot2Fg7GripperCommandRequestControlKind, str]) -> object:
  return OnRobot2Fg7GripperCommandRequestControlKind(data).value

@dataclass
class OnRobot2Fg7GripperCommandRequest:
  """Control the OnRobot 2FG7 gripper (end effector) of the robot
"""
  grip_direction: OnRobot2Fg7GripperCommandRequestGripDirection
  control_kind: Union[OnRobot2Fg7GripperCommandRequestControlKind, None] = None
  target_force: Union[ForceUnit, None] = None
  target_grip_width: Union[LinearUnit, None] = None

  def __post_init__(self):
    # Type check incoming model - raise error if invalid (required or wrong type)
    if self.grip_direction is None:
      raise ValueError("grip_direction is required for OnRobot2Fg7GripperCommandRequest")
    if not isinstance(self.grip_direction, OnRobot2Fg7GripperCommandRequestGripDirection):
      raise TypeError("grip_direction must be of type OnRobot2Fg7GripperCommandRequestGripDirection for OnRobot2Fg7GripperCommandRequest, got " + type(self.grip_direction).__name__)
    if not (self.control_kind is None or isinstance(self.control_kind, OnRobot2Fg7GripperCommandRequestControlKind)):
      raise TypeError("control_kind must be of type OnRobot2Fg7GripperCommandRequestControlKind for OnRobot2Fg7GripperCommandRequest, got " + type(self.control_kind).__name__)
    if not (self.target_force is None or isinstance(self.target_force, ForceUnit)):
      raise TypeError("target_force must be of type ForceUnit for OnRobot2Fg7GripperCommandRequest, got " + type(self.target_force).__name__)
    if not (self.target_grip_width is None or isinstance(self.target_grip_width, LinearUnit)):
      raise TypeError("target_grip_width must be of type LinearUnit for OnRobot2Fg7GripperCommandRequest, got " + type(self.target_grip_width).__name__)

def parse_on_robot_2_fg_7_gripper_command_request(data: object):
  return OnRobot2Fg7GripperCommandRequest(
    grip_direction=parse_on_robot_2_fg_7_gripper_command_request_grip_direction(data["grip_direction"]),
    control_kind=parse_on_robot_2_fg_7_gripper_command_request_control_kind(data["control_kind"]) if "control_kind" in data else None,
    target_force=parse_force_unit(data["target_force"]) if "target_force" in data else None,
    target_grip_width=parse_linear_unit(data["target_grip_width"]) if "target_grip_width" in data else None,
  )

def serialize_on_robot_2_fg_7_gripper_command_request(data: OnRobot2Fg7GripperCommandRequest) -> object:
  return {
    "grip_direction": serialize_on_robot_2_fg_7_gripper_command_request_grip_direction(data.grip_direction),
    "control_kind": None if data.control_kind is None else serialize_on_robot_2_fg_7_gripper_command_request_control_kind(data.control_kind),
    "target_force": None if data.target_force is None else serialize_force_unit(data.target_force),
    "target_grip_width": None if data.target_grip_width is None else serialize_linear_unit(data.target_grip_width),
  }

class OnRobot3Fg15GripperCommandRequestGripDirection(Enum):
  Inward = "inward"
  Outward = "outward"

def parse_on_robot_3_fg_15_gripper_command_request_grip_direction(data: object) -> OnRobot3Fg15GripperCommandRequestGripDirection:
  return OnRobot3Fg15GripperCommandRequestGripDirection(data)

def serialize_on_robot_3_fg_15_gripper_command_request_grip_direction(data: Union[OnRobot3Fg15GripperCommandRequestGripDirection, str]) -> object:
  return OnRobot3Fg15GripperCommandRequestGripDirection(data).value

class OnRobot3Fg15GripperCommandRequestControlKind(Enum):
  Move = "move"
  ForceGrip = "force_grip"
  FlexibleForceGrip = "flexible_force_grip"

def parse_on_robot_3_fg_15_gripper_command_request_control_kind(data: object) -> OnRobot3Fg15GripperCommandRequestControlKind:
  return OnRobot3Fg15GripperCommandRequestControlKind(data)

def serialize_on_robot_3_fg_15_gripper_command_request_control_kind(data: Union[OnRobot3Fg15GripperCommandRequestControlKind, str]) -> object:
  return OnRobot3Fg15GripperCommandRequestControlKind(data).value

@dataclass
class OnRobot3Fg15GripperCommandRequest:
  """Control the OnRobot 3FG15 gripper (end effector) of the robot
"""
  grip_direction: OnRobot3Fg15GripperCommandRequestGripDirection
  target_force: Union[ForceUnit, None] = None
  target_grip_diameter: Union[LinearUnit, None] = None
  control_kind: Union[OnRobot3Fg15GripperCommandRequestControlKind, None] = None

  def __post_init__(self):
    # Type check incoming model - raise error if invalid (required or wrong type)
    if self.grip_direction is None:
      raise ValueError("grip_direction is required for OnRobot3Fg15GripperCommandRequest")
    if not isinstance(self.grip_direction, OnRobot3Fg15GripperCommandRequestGripDirection):
      raise TypeError("grip_direction must be of type OnRobot3Fg15GripperCommandRequestGripDirection for OnRobot3Fg15GripperCommandRequest, got " + type(self.grip_direction).__name__)
    if not (self.target_force is None or isinstance(self.target_force, ForceUnit)):
      raise TypeError("target_force must be of type ForceUnit for OnRobot3Fg15GripperCommandRequest, got " + type(self.target_force).__name__)
    if not (self.target_grip_diameter is None or isinstance(self.target_grip_diameter, LinearUnit)):
      raise TypeError("target_grip_diameter must be of type LinearUnit for OnRobot3Fg15GripperCommandRequest, got " + type(self.target_grip_diameter).__name__)
    if not (self.control_kind is None or isinstance(self.control_kind, OnRobot3Fg15GripperCommandRequestControlKind)):
      raise TypeError("control_kind must be of type OnRobot3Fg15GripperCommandRequestControlKind for OnRobot3Fg15GripperCommandRequest, got " + type(self.control_kind).__name__)

def parse_on_robot_3_fg_15_gripper_command_request(data: object):
  return OnRobot3Fg15GripperCommandRequest(
    grip_direction=parse_on_robot_3_fg_15_gripper_command_request_grip_direction(data["grip_direction"]),
    target_force=parse_force_unit(data["target_force"]) if "target_force" in data else None,
    target_grip_diameter=parse_linear_unit(data["target_grip_diameter"]) if "target_grip_diameter" in data else None,
    control_kind=parse_on_robot_3_fg_15_gripper_command_request_control_kind(data["control_kind"]) if "control_kind" in data else None,
  )

def serialize_on_robot_3_fg_15_gripper_command_request(data: OnRobot3Fg15GripperCommandRequest) -> object:
  return {
    "grip_direction": serialize_on_robot_3_fg_15_gripper_command_request_grip_direction(data.grip_direction),
    "target_force": None if data.target_force is None else serialize_force_unit(data.target_force),
    "target_grip_diameter": None if data.target_grip_diameter is None else serialize_linear_unit(data.target_grip_diameter),
    "control_kind": None if data.control_kind is None else serialize_on_robot_3_fg_15_gripper_command_request_control_kind(data.control_kind),
  }

@dataclass
class GripperCommandRequest:
  """Control the gripper (end effector) of the robot
"""
  kind: GripperCommandRequestKind
  onrobot_2fg7: Union[OnRobot2Fg7GripperCommandRequest, None] = None
  onrobot_3fg15: Union[OnRobot3Fg15GripperCommandRequest, None] = None

  def __post_init__(self):
    # Type check incoming model - raise error if invalid (required or wrong type)
    if self.kind is None:
      raise ValueError("kind is required for GripperCommandRequest")
    if not isinstance(self.kind, GripperCommandRequestKind):
      raise TypeError("kind must be of type GripperCommandRequestKind for GripperCommandRequest, got " + type(self.kind).__name__)
    if not (self.onrobot_2fg7 is None or isinstance(self.onrobot_2fg7, OnRobot2Fg7GripperCommandRequest)):
      raise TypeError("onrobot_2fg7 must be of type OnRobot2Fg7GripperCommandRequest for GripperCommandRequest, got " + type(self.onrobot_2fg7).__name__)
    if not (self.onrobot_3fg15 is None or isinstance(self.onrobot_3fg15, OnRobot3Fg15GripperCommandRequest)):
      raise TypeError("onrobot_3fg15 must be of type OnRobot3Fg15GripperCommandRequest for GripperCommandRequest, got " + type(self.onrobot_3fg15).__name__)

def parse_gripper_command_request(data: object):
  return GripperCommandRequest(
    kind=parse_gripper_command_request_kind(data["kind"]),
    onrobot_2fg7=parse_on_robot_2_fg_7_gripper_command_request(data["onrobot_2fg7"]) if "onrobot_2fg7" in data else None,
    onrobot_3fg15=parse_on_robot_3_fg_15_gripper_command_request(data["onrobot_3fg15"]) if "onrobot_3fg15" in data else None,
  )

def serialize_gripper_command_request(data: GripperCommandRequest) -> object:
  return {
    "kind": serialize_gripper_command_request_kind(data.kind),
    "onrobot_2fg7": None if data.onrobot_2fg7 is None else serialize_on_robot_2_fg_7_gripper_command_request(data.onrobot_2fg7),
    "onrobot_3fg15": None if data.onrobot_3fg15 is None else serialize_on_robot_3_fg_15_gripper_command_request(data.onrobot_3fg15),
  }

class BrakesStateState(Enum):
  Engaged = "engaged"
  Disengaged = "disengaged"

def parse_brakes_state_state(data: object) -> BrakesStateState:
  return BrakesStateState(data)

def serialize_brakes_state_state(data: Union[BrakesStateState, str]) -> object:
  return BrakesStateState(data).value

@dataclass
class BrakesState:
  """State of the robot joint brakes. Each joint contains a brake which can be engaged when the robot is at a standstill to prevent the robot from moving.
| State           | Purpose |
| -------------- | ------- |
| &#x60;engaged&#x60;      | Robot Brakes are engaged, robot is not able to move |
| &#x60;disengaged&#x60;   | Robot Brakes are disengaged, robot can move freely |
"""
  state: BrakesStateState

  def __post_init__(self):
    # Type check incoming model - raise error if invalid (required or wrong type)
    if self.state is None:
      raise ValueError("state is required for BrakesState")
    if not isinstance(self.state, BrakesStateState):
      raise TypeError("state must be of type BrakesStateState for BrakesState, got " + type(self.state).__name__)

def parse_brakes_state(data: object):
  return BrakesState(
    state=parse_brakes_state_state(data["state"]),
  )

def serialize_brakes_state(data: BrakesState) -> object:
  return {
    "state": serialize_brakes_state_state(data.state),
  }

class ArmPositionUpdateRequestKind(Enum):
  TooltipPositions = "tooltip_positions"
  TooltipPosition = "tooltip_position"
  JointRotations = "joint_rotations"
  JointRotation = "joint_rotation"

def parse_arm_position_update_request_kind(data: object) -> ArmPositionUpdateRequestKind:
  return ArmPositionUpdateRequestKind(data)

def serialize_arm_position_update_request_kind(data: Union[ArmPositionUpdateRequestKind, str]) -> object:
  return ArmPositionUpdateRequestKind(data).value

ArmPositionUpdateRequestTooltipPositions = List[PositionAndOrientation]

def parse_arm_position_update_request_tooltip_positions(data: object) -> ArmPositionUpdateRequestTooltipPositions:
  return [parse_position_and_orientation(item) for item in data]

def serialize_arm_position_update_request_tooltip_positions(data: ArmPositionUpdateRequestTooltipPositions) -> List[object]:
  return [serialize_position_and_orientation(item) for item in data]

@dataclass
class ArmJointRotations:
  """Rotational positions of arm joints"""
  joints: JointRotations

  def __post_init__(self):
    # Type check incoming model - raise error if invalid (required or wrong type)
    if self.joints is None:
      raise ValueError("joints is required for ArmJointRotations")
    if not isinstance(self.joints, tuple):
      raise TypeError("joints must be of type tuple for ArmJointRotations, got " + type(self.joints).__name__)

def parse_arm_joint_rotations(data: object):
  return ArmJointRotations(
    joints=parse_joint_rotations(data["joints"]),
  )

def serialize_arm_joint_rotations(data: ArmJointRotations) -> object:
  return {
    "joints": serialize_joint_rotations(data.joints),
  }

ArmPositionUpdateRequestJointRotations = List[ArmJointRotations]

def parse_arm_position_update_request_joint_rotations(data: object) -> ArmPositionUpdateRequestJointRotations:
  return [parse_arm_joint_rotations(item) for item in data]

def serialize_arm_position_update_request_joint_rotations(data: ArmPositionUpdateRequestJointRotations) -> List[object]:
  return [serialize_arm_joint_rotations(item) for item in data]

class ArmPositionUpdateRequestResponseKind(Enum):
  Sync = "sync"
  EventStream = "event_stream"

def parse_arm_position_update_request_response_kind(data: object) -> ArmPositionUpdateRequestResponseKind:
  return ArmPositionUpdateRequestResponseKind(data)

def serialize_arm_position_update_request_response_kind(data: Union[ArmPositionUpdateRequestResponseKind, str]) -> object:
  return ArmPositionUpdateRequestResponseKind(data).value

class ArmPositionUpdateRequestResponseEventStreamSubscriptionsSubscriptions(Enum):
  All = "all"
  Events = "events"
  Positions = "positions"

def parse_arm_position_update_request_response_event_stream_subscriptions_subscriptions(data: object) -> ArmPositionUpdateRequestResponseEventStreamSubscriptionsSubscriptions:
  return ArmPositionUpdateRequestResponseEventStreamSubscriptionsSubscriptions(data)

def serialize_arm_position_update_request_response_event_stream_subscriptions_subscriptions(data: Union[ArmPositionUpdateRequestResponseEventStreamSubscriptionsSubscriptions, str]) -> object:
  return ArmPositionUpdateRequestResponseEventStreamSubscriptionsSubscriptions(data).value

ArmPositionUpdateRequestResponseEventStreamSubscriptions = List[ArmPositionUpdateRequestResponseEventStreamSubscriptionsSubscriptions]

def parse_arm_position_update_request_response_event_stream_subscriptions(data: object) -> ArmPositionUpdateRequestResponseEventStreamSubscriptions:
  return [parse_arm_position_update_request_response_event_stream_subscriptions_subscriptions(item) for item in data]

def serialize_arm_position_update_request_response_event_stream_subscriptions(data: ArmPositionUpdateRequestResponseEventStreamSubscriptions) -> List[object]:
  return [serialize_arm_position_update_request_response_event_stream_subscriptions_subscriptions(item) for item in data]

@dataclass
class ArmPositionUpdateRequestResponseEventStream:
  subscriptions: ArmPositionUpdateRequestResponseEventStreamSubscriptions

  def __post_init__(self):
    # Type check incoming model - raise error if invalid (required or wrong type)
    if self.subscriptions is None:
      raise ValueError("subscriptions is required for ArmPositionUpdateRequestResponseEventStream")
    if not isinstance(self.subscriptions, list):
      raise TypeError("subscriptions must be of type list for ArmPositionUpdateRequestResponseEventStream, got " + type(self.subscriptions).__name__)

def parse_arm_position_update_request_response_event_stream(data: object):
  return ArmPositionUpdateRequestResponseEventStream(
    subscriptions=parse_arm_position_update_request_response_event_stream_subscriptions(data["subscriptions"]),
  )

def serialize_arm_position_update_request_response_event_stream(data: ArmPositionUpdateRequestResponseEventStream) -> object:
  return {
    "subscriptions": serialize_arm_position_update_request_response_event_stream_subscriptions(data.subscriptions),
  }

@dataclass
class ArmPositionUpdateRequestResponse:
  """Specify how the response should be sent
"""
  kind: ArmPositionUpdateRequestResponseKind
  event_stream: Union[ArmPositionUpdateRequestResponseEventStream, None] = None

  def __post_init__(self):
    # Type check incoming model - raise error if invalid (required or wrong type)
    if self.kind is None:
      raise ValueError("kind is required for ArmPositionUpdateRequestResponse")
    if not isinstance(self.kind, ArmPositionUpdateRequestResponseKind):
      raise TypeError("kind must be of type ArmPositionUpdateRequestResponseKind for ArmPositionUpdateRequestResponse, got " + type(self.kind).__name__)
    if not (self.event_stream is None or isinstance(self.event_stream, ArmPositionUpdateRequestResponseEventStream)):
      raise TypeError("event_stream must be of type ArmPositionUpdateRequestResponseEventStream for ArmPositionUpdateRequestResponse, got " + type(self.event_stream).__name__)

def parse_arm_position_update_request_response(data: object):
  return ArmPositionUpdateRequestResponse(
    kind=parse_arm_position_update_request_response_kind(data["kind"]),
    event_stream=parse_arm_position_update_request_response_event_stream(data["event_stream"]) if "event_stream" in data else None,
  )

def serialize_arm_position_update_request_response(data: ArmPositionUpdateRequestResponse) -> object:
  return {
    "kind": serialize_arm_position_update_request_response_kind(data.kind),
    "event_stream": None if data.event_stream is None else serialize_arm_position_update_request_response_event_stream(data.event_stream),
  }

@dataclass
class ArmPositionUpdateRequest:
  """Move the robot"""
  kind: ArmPositionUpdateRequestKind
  tooltip_positions: Union[ArmPositionUpdateRequestTooltipPositions, None] = None
  tooltip_position: Union[PositionAndOrientation, None] = None
  joint_rotations: Union[ArmPositionUpdateRequestJointRotations, None] = None
  joint_rotation: Union[ArmJointRotations, None] = None
  response: Union[ArmPositionUpdateRequestResponse, None] = None

  def __post_init__(self):
    # Type check incoming model - raise error if invalid (required or wrong type)
    if self.kind is None:
      raise ValueError("kind is required for ArmPositionUpdateRequest")
    if not isinstance(self.kind, ArmPositionUpdateRequestKind):
      raise TypeError("kind must be of type ArmPositionUpdateRequestKind for ArmPositionUpdateRequest, got " + type(self.kind).__name__)
    if not (self.tooltip_positions is None or isinstance(self.tooltip_positions, list)):
      raise TypeError("tooltip_positions must be of type list for ArmPositionUpdateRequest, got " + type(self.tooltip_positions).__name__)
    if not (self.tooltip_position is None or isinstance(self.tooltip_position, PositionAndOrientation)):
      raise TypeError("tooltip_position must be of type PositionAndOrientation for ArmPositionUpdateRequest, got " + type(self.tooltip_position).__name__)
    if not (self.joint_rotations is None or isinstance(self.joint_rotations, list)):
      raise TypeError("joint_rotations must be of type list for ArmPositionUpdateRequest, got " + type(self.joint_rotations).__name__)
    if not (self.joint_rotation is None or isinstance(self.joint_rotation, ArmJointRotations)):
      raise TypeError("joint_rotation must be of type ArmJointRotations for ArmPositionUpdateRequest, got " + type(self.joint_rotation).__name__)
    if not (self.response is None or isinstance(self.response, ArmPositionUpdateRequestResponse)):
      raise TypeError("response must be of type ArmPositionUpdateRequestResponse for ArmPositionUpdateRequest, got " + type(self.response).__name__)

def parse_arm_position_update_request(data: object):
  return ArmPositionUpdateRequest(
    kind=parse_arm_position_update_request_kind(data["kind"]),
    tooltip_positions=parse_arm_position_update_request_tooltip_positions(data["tooltip_positions"]) if "tooltip_positions" in data else None,
    tooltip_position=parse_position_and_orientation(data["tooltip_position"]) if "tooltip_position" in data else None,
    joint_rotations=parse_arm_position_update_request_joint_rotations(data["joint_rotations"]) if "joint_rotations" in data else None,
    joint_rotation=parse_arm_joint_rotations(data["joint_rotation"]) if "joint_rotation" in data else None,
    response=parse_arm_position_update_request_response(data["response"]) if "response" in data else None,
  )

def serialize_arm_position_update_request(data: ArmPositionUpdateRequest) -> object:
  return {
    "kind": serialize_arm_position_update_request_kind(data.kind),
    "tooltip_positions": None if data.tooltip_positions is None else serialize_arm_position_update_request_tooltip_positions(data.tooltip_positions),
    "tooltip_position": None if data.tooltip_position is None else serialize_position_and_orientation(data.tooltip_position),
    "joint_rotations": None if data.joint_rotations is None else serialize_arm_position_update_request_joint_rotations(data.joint_rotations),
    "joint_rotation": None if data.joint_rotation is None else serialize_arm_joint_rotations(data.joint_rotation),
    "response": None if data.response is None else serialize_arm_position_update_request_response(data.response),
  }

class RobotControlModeKind(Enum):
  Api = "api"
  RoutineEditor = "routine_editor"

def parse_robot_control_mode_kind(data: object) -> RobotControlModeKind:
  return RobotControlModeKind(data)

def serialize_robot_control_mode_kind(data: Union[RobotControlModeKind, str]) -> object:
  return RobotControlModeKind(data).value

@dataclass
class RobotControlMode:
  """Definition of Robot Control State, which tells you which service or system is controlling the Robot"""
  kind: Union[RobotControlModeKind, None] = None

  def __post_init__(self):
    # Type check incoming model - raise error if invalid (required or wrong type)
    if not (self.kind is None or isinstance(self.kind, RobotControlModeKind)):
      raise TypeError("kind must be of type RobotControlModeKind for RobotControlMode, got " + type(self.kind).__name__)

def parse_robot_control_mode(data: object):
  return RobotControlMode(
    kind=parse_robot_control_mode_kind(data["kind"]) if "kind" in data else None,
  )

def serialize_robot_control_mode(data: RobotControlMode) -> object:
  return {
    "kind": None if data.kind is None else serialize_robot_control_mode_kind(data.kind),
  }

class GripperConfigurationKind(Enum):
  NoneConnected = "none_connected"
  Onrobot2Fg7 = "onrobot_2fg7"
  Onrobot3Fg15 = "onrobot_3fg15"

def parse_gripper_configuration_kind(data: object) -> GripperConfigurationKind:
  return GripperConfigurationKind(data)

def serialize_gripper_configuration_kind(data: Union[GripperConfigurationKind, str]) -> object:
  return GripperConfigurationKind(data).value

@dataclass
class GripperConfiguration:
  """Configuration of gripper, also known as End Effector"""
  kind: Union[GripperConfigurationKind, None] = None

  def __post_init__(self):
    # Type check incoming model - raise error if invalid (required or wrong type)
    if not (self.kind is None or isinstance(self.kind, GripperConfigurationKind)):
      raise TypeError("kind must be of type GripperConfigurationKind for GripperConfiguration, got " + type(self.kind).__name__)

def parse_gripper_configuration(data: object):
  return GripperConfiguration(
    kind=parse_gripper_configuration_kind(data["kind"]) if "kind" in data else None,
  )

def serialize_gripper_configuration(data: GripperConfiguration) -> object:
  return {
    "kind": None if data.kind is None else serialize_gripper_configuration_kind(data.kind),
  }

@dataclass
class RuntimeVariable:
  """Runtime Variable state"""
  value: Union[str, None] = None

  def __post_init__(self):
    # Type check incoming model - raise error if invalid (required or wrong type)
    if not (self.value is None or isinstance(self.value, str)):
      raise TypeError("value must be of type str for RuntimeVariable, got " + type(self.value).__name__)

def parse_runtime_variable(data: object):
  return RuntimeVariable(
    value=parse_str(data["value"]) if "value" in data else None,
  )

def serialize_runtime_variable(data: RuntimeVariable) -> object:
  return {
    "value": None if data.value is None else serialize_str(data.value),
  }

@dataclass
class Plane:
  """Plane in 3D space"""
  id: Union[str, None] = None
  name: Union[str, None] = None

  def __post_init__(self):
    # Type check incoming model - raise error if invalid (required or wrong type)
    if not (self.id is None or isinstance(self.id, str)):
      raise TypeError("id must be of type str for Plane, got " + type(self.id).__name__)
    if not (self.name is None or isinstance(self.name, str)):
      raise TypeError("name must be of type str for Plane, got " + type(self.name).__name__)

def parse_plane(data: object):
  return Plane(
    id=parse_str(data["id"]) if "id" in data else None,
    name=parse_str(data["name"]) if "name" in data else None,
  )

def serialize_plane(data: Plane) -> object:
  return {
    "id": None if data.id is None else serialize_str(data.id),
    "name": None if data.name is None else serialize_str(data.name),
  }

PlanesPaginatedResponseItems = List[Plane]

def parse_planes_paginated_response_items(data: object) -> PlanesPaginatedResponseItems:
  return [parse_plane(item) for item in data]

def serialize_planes_paginated_response_items(data: PlanesPaginatedResponseItems) -> List[object]:
  return [serialize_plane(item) for item in data]

@dataclass
class PlanesPaginatedResponse:
  items: Union[PlanesPaginatedResponseItems, None] = None
  total: Union[int, None] = None

  def __post_init__(self):
    # Type check incoming model - raise error if invalid (required or wrong type)
    if not (self.items is None or isinstance(self.items, list)):
      raise TypeError("items must be of type list for PlanesPaginatedResponse, got " + type(self.items).__name__)
    if not (self.total is None or isinstance(self.total, int)):
      raise TypeError("total must be of type int for PlanesPaginatedResponse, got " + type(self.total).__name__)

def parse_planes_paginated_response(data: object):
  return PlanesPaginatedResponse(
    items=parse_planes_paginated_response_items(data["items"]) if "items" in data else None,
    total=parse_int(data["total"]) if "total" in data else None,
  )

def serialize_planes_paginated_response(data: PlanesPaginatedResponse) -> object:
  return {
    "items": None if data.items is None else serialize_planes_paginated_response_items(data.items),
    "total": None if data.total is None else serialize_int(data.total),
  }

@dataclass
class Camera:
  """Camera connected to the robot"""
  id: str
  name: str

  def __post_init__(self):
    if self.id is None:
      raise ValueError("id is required for Camera")
    if not isinstance(self.id, str):
      raise TypeError("id must be of type str for Camera")
    if self.name is None:
      raise ValueError("name is required for Camera")
    if not isinstance(self.name, str):
      raise TypeError("name must be of type str for Camera")

def parse_camera(data: object):
  return Camera(
    id=parse_str(data["id"]),
    name=parse_str(data["name"]),
  )

def serialize_camera(data: Camera) -> object:
  return {
    "id": serialize_str(data.id),
    "name": serialize_str(data.name),
  }

PaginatedCameraItems = List[Camera]

def parse_paginated_camera_items(data: object) -> PaginatedCameraItems:
  return [parse_camera(item) for item in data]

def serialize_paginated_camera_items(data: PaginatedCameraItems) -> List[object]:
  return [serialize_camera(item) for item in data]

@dataclass
class PaginatedCamera:
  """Paginated Camera result"""
  items: PaginatedCameraItems
  total: int

  def __post_init__(self):
    if self.items is None:
      raise ValueError("items is required for PaginatedCamera")
    if not isinstance(self.items, list):
      raise TypeError("items must be of type list for PaginatedCamera")
    if self.total is None:
      raise ValueError("total is required for PaginatedCamera")
    if not isinstance(self.total, int):
      raise TypeError("total must be of type int for PaginatedCamera")

def parse_paginated_camera(data: object):
  return PaginatedCamera(
    items=parse_paginated_camera_items(data["items"]),
    total=parse_int(data["total"]),
  )

def serialize_paginated_camera(data: PaginatedCamera) -> object:
  return {
    "items": serialize_paginated_camera_items(data.items),
    "total": serialize_int(data.total),
  }

