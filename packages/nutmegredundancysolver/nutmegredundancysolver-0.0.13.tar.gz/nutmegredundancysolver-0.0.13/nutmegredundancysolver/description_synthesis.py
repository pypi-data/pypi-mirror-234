from searchdatamodels import *
from typing import List
import requests
from sumy.summarizers.lex_rank import LexRankSummarizer
from sumy.summarizers.luhn import LuhnSummarizer
from sumy.summarizers.lsa import LsaSummarizer
from sumy.summarizers.text_rank import TextRankSummarizer
from sumy.summarizers.kl import KLSummarizer
from sumy.parsers.plaintext import PlaintextParser
from sumy.nlp.tokenizers import Tokenizer
from scipy.spatial.distance import euclidean,cosine
import nltk
nltk.download('punkt')

'''
often times candidates' projects/experiences/education will have summaries/Descriptions
this requires working with the DescriptionModel class to compare and merge descriptions
'''

LEX_RANK='lex_rank'
LUHN='luhn'
LSA='latent_semantic_analysis'
TEXT_RANK='text_rank'
#lsa and text_rank are the only ones that have any real semantic value so they're the best ones to use
KULL_LIEB='kullback_lieber'


BART='facebook/bart-large-cnn'
PEGASUS='google/pegasus-xsum'

#the T5 summarization(s) have not been implemented yet
T5_BASE='t5-base'
T5_11B='t5-11b'
T5_SMALL='t5-small'

VECTOR="vector"

EXTRACTIVE_NAMES=[LEX_RANK, LUHN, LSA, TEXT_RANK, KULL_LIEB]

ABSTRACTIVE_NAMES=[BART,PEGASUS]

HF_TOKEN="Bearer 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"

def extractive_summary(text: str, extractive_name: str, sentences_count: int)-> str:
    '''The function `extractive_summary` takes in a text, an extractive method name, a language, and a
    number of sentences count, and returns an extractive summary of the text using the specified method.
    
    Parameters
    ----------
    text : str
        The `text` parameter is a string that represents the input text from which you want to extract a
    summary.
    extractive_name : str
        The `extractive_name` parameter is a string that specifies the name of the extractive summarization
        method to be used. It can have one of the following values: [LEX_RANK, LUHN, LSA, TEXT_RANK, KULL_LIEB]
    sentences_count : int
        The parameter "sentences_count" is an integer that specifies the number of sentences you want in
        the extractive summary.
    
    Returns
    -------
        a string that represents the extractive summary of the given text.
    
    '''
    lang_tokenizer=Tokenizer('english') #only supporting english at the moment; this may change
    parser=PlaintextParser.from_string(text, lang_tokenizer)
    if extractive_name == LEX_RANK:
        summarizer=LexRankSummarizer()
    elif extractive_name==LUHN:
        summarizer=LuhnSummarizer()
    elif extractive_name==LSA:
        summarizer=LsaSummarizer()
    elif extractive_name==TEXT_RANK:
        summarizer=TextRankSummarizer()
    elif extractive_name==KULL_LIEB:
        summarizer=KLSummarizer()
    else:
        raise Exception("unknown extractive summary method {}".format(extractive_name))
    sentences=summarizer(parser.document, sentences_count=sentences_count)
    return ' '.join([s.__str__() for s in sentences])

def abstractive_summary(text: str, abstractive_name: str)-> str:
    '''The `abstractive_summary` function takes in a text and an abstractive model name, and returns a
    one-sentence summary of the text using the specified abstractive model. Currently works by using the 
    HF inference API, as that was the fastest option. However, the HF Inference API does not support T5
    and there might be faster options.
    
    Parameters
    ----------
    text : str
        The `text` parameter is a string that represents the input text for which you want to generate an
    abstractive summary. This can be any piece of text, such as an article, a blog post, or a document.
    abstractive_name : str
        The `abstractive_name` parameter is the name or identifier of the abstractive summarization model
    you want to use. It is used to specify which model should be used for generating the summary.
    
    Returns
    -------
        The function `abstractive_summary` returns the summary text generated by the abstractive
    summarization model.
    
    '''
    if abstractive_name not in ABSTRACTIVE_NAMES:
        raise Exception("unknown extractive summary method {}".format(abstractive_name))
    API_URL = "https://api-inference.huggingface.co/models/{}".format(abstractive_name)
    headers = {"Authorization": HF_TOKEN}
    payload={
        "inputs": text
    }
    response = requests.post(API_URL, headers=headers, json=payload)
    while response.status_code!=200:
        response = requests.post(API_URL, headers=headers, json=payload)
    return response.json()[0]['summary_text']

def sentence_embedding_summary(text: str, sentence_embedding_name: str, distance_threshold: float=DEFAULT_DISTANCE_THRESHOLD) -> str:
    '''The function `sentence_embedding_summary` takes a text and a sentence embedding method as input and
    returns a summary of the text by grouping similar sentences together based on their embeddings.
    
    Parameters
    ----------
    text : str
        The `text` parameter is a string that represents the input text that you want to summarize. It can
    be a paragraph or a longer piece of text.
    sentence_embedding_name : str
        The parameter "sentence_embedding_name" is the name of the sentence embedding model that will be
    used to create embeddings for each sentence in the text. This model should be one of the models
    listed in the "SENTENCE_EMBEDDING_MODELS" variable.
    distance_threshold : float
        The distance_threshold parameter is a float value that represents the maximum cosine distance
    allowed between two sentence embeddings for them to be considered redundant. If the cosine distance
    between two sentence embeddings is less than or equal to the distance_threshold, the second sentence
    is considered redundant and is not included in the final summary.
    
    Returns
    -------
        a summary of the input text by selecting sentences that have unique sentence embeddings. The
    selected sentences are concatenated and returned as a string.
    
    '''
    if sentence_embedding_name not in SENTENCE_EMBEDDING_MODELS:
        raise Exception("unknown vector summary method {}".format(sentence_embedding_name))
    text_chunk_list=text.split('.')
    embedding_text_pairs_list=[
        (text_chunk, create_embedding(text_chunk)) for text_chunk in text_chunk_list
    ]
    final_embedding_text_pairs_list=[embedding_text_pairs_list[0]]
    for text_chunk, embedding in embedding_text_pairs_list[1:]:
        redundant_text_chunk=False
        for j in range(len(final_embedding_text_pairs_list)):
            preexisting_embedding=final_embedding_text_pairs_list[j][1]
            if cosine(preexisting_embedding, embedding) <= distance_threshold:
                redundant_text_chunk=True
                break
        if redundant_text_chunk is False:
            final_embedding_text_pairs_list.append((text_chunk, embedding))
    return '. '.join([text_chunk for (text_chunk, embedding) in final_embedding_text_pairs_list])
    
    

def text_summary(text: str, summary_name: str) -> str:
    if summary_name in EXTRACTIVE_NAMES:
        return extractive_summary(text, summary_name, 3) 
        #3 is arbitrarily chosen on the basis of 3 sentences is a good length for a summary
        # Further work could be done to determine optimal summary length from the text
    elif summary_name in ABSTRACTIVE_NAMES:
        return abstractive_summary(text, summary_name)
    elif summary_name in SENTENCE_EMBEDDING_MODELS:
        return sentence_embedding_summary(text, summary_name)

def merge_descriptions(description_list: List[DescriptionModel], summary_name: str = LSA) -> List[DescriptionModel]:
    '''The function `merge_descriptions` takes a list of `DescriptionModel` objects and merges descriptions
    with the same text, summarizing the merged text using a specified summary algorithm.
    
    Parameters
    ----------
    description_list : List[DescriptionModel]
        A list of DescriptionModel objects, which contain a Text attribute representing the description
    text.
    summary_name : str
        The `summary_name` parameter is a string that specifies the type of summary to be generated for the
    merged descriptions. It is used as an argument in the `text_summary` function.
    
    Returns
    -------
        a list of DescriptionModel objects.
    
    '''
    if len(description_list) <2:
        return description_list
    j=0
    while j < len(description_list):
        desc=description_list[j]
        k=j+1
        text_list=[desc.Text]
        while k < len(description_list):
            next_desc=description_list[k]
            if desc==next_desc:
                text_list.append(next_desc.Text)
                description_list.pop(k)
            else:
                k+=1
        if len(text_list)>1:
            text=' '.join(text_list)
            summarized_text=text_summary(text, summary_name)
            desc.Text=summarized_text
        j+=1
    return description_list