{"version":3,"file":"lib_index_js.f1f6a0d009883b94d4a5.js","mappings":";;;;;;;;;;;;;;;;;;;;AAAqD;AACoB;AACV;AAC/D;AACA;AACA;AACO;AACP;AACA;AACA,eAAe,kEAAgB,EAAE,+DAAa;AAC9C,eAAe,yEAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,kDAAkD,eAAe;AACjE,SAAS;AACT;AACA,oDAAoD;AACpD,SAAS;AACT,QAAQ,iEAAe;AACvB,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA,iEAAe,cAAc,EAAC;AAC9B","sources":["webpack://cognite_jupyterlab_metrics/./lib/index.js"],"sourcesContent":["import { IThemeManager } from '@jupyterlab/apputils';\nimport { INotebookTracker, NotebookActions } from '@jupyterlab/notebook';\nimport { ISettingRegistry } from '@jupyterlab/settingregistry';\n/**\n * A plugin that sends notebook events to Fusion.\n */\nexport const cogniteMetrics = {\n    id: 'cognite_jupyterlab_metrics:plugin',\n    autoStart: true,\n    requires: [INotebookTracker, IThemeManager],\n    optional: [ISettingRegistry],\n    activate: (app, nbTracker, manager, settingRegistry) => {\n        // Try to read the settings so that the cell toolbar updates\n        if (settingRegistry) {\n            void settingRegistry.load('@jupyterlab/comments-extension:notebook');\n        }\n        const executedCode = {};\n        let currentNotebook = undefined;\n        const track = (eventName, data) => {\n            window.parent.postMessage({\n                event: 'jupyterliteEvent',\n                data: { eventName, data }\n            }, '*');\n        };\n        window.nbTracker = nbTracker;\n        nbTracker.currentChanged.connect((sender, notebook) => {\n            const notebookTitle = (notebook === null || notebook === void 0 ? void 0 : notebook.context)._path;\n            currentNotebook = notebookTitle;\n            track('jupyterLiteNotebookChanged', { notebookTitle });\n        });\n        nbTracker.activeCellChanged.connect((sender, cell) => {\n            track('jupyterLiteActiveCellChanged', {});\n        });\n        NotebookActions.executed.connect((sender, args) => {\n            const { cell } = args;\n            // console.log('Cell: ', cell);\n            window.cell = cell;\n            const cellModel = cell.model.toJSON();\n            window.cellModel = cellModel;\n            console.log('Cell model: ', cellModel);\n            const executionCount = cellModel.execution_count;\n            const code = cellModel.source;\n            const cellType = cellModel.cell_type;\n            const outputs = cellModel.outputs;\n            const anyErrors = outputs.some((output) => output.output_type === 'error');\n            if (currentNotebook === undefined) {\n                return;\n            }\n            if (executedCode[currentNotebook] === undefined) {\n                executedCode[currentNotebook] = [];\n            }\n            executedCode[currentNotebook].push(code);\n            track('jupyterLiteCellExecuted', {\n                cellType,\n                executionCount,\n                code,\n                success: !anyErrors\n            });\n            if (anyErrors) {\n                const errorOutput = outputs.find((output) => output.output_type === 'error');\n                const errorName = errorOutput.ename;\n                const errorValue = errorOutput.evalue;\n                const errorTraceback = errorOutput.traceback.join('\\n');\n                track('jupyterLiteCellError', {\n                    cellType,\n                    executionCount,\n                    code,\n                    errorName,\n                    errorValue,\n                    errorTraceback,\n                    executedCode: executedCode[currentNotebook]\n                });\n            }\n        });\n    }\n};\nexport default cogniteMetrics;\n//# sourceMappingURL=index.js.map"],"names":[],"sourceRoot":""}